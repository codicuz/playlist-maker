==== ./app/src/main/java/com/practicum/playlistmaker/App.kt ====
package com.practicum.playlistmaker

import android.app.Application
import com.practicum.playlistmaker.di.appModule
import com.practicum.playlistmaker.domain.theme.ThemeRepository
import org.koin.android.ext.koin.androidContext
import org.koin.core.context.GlobalContext.startKoin

class App : Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
            androidContext(this@App)
            modules(appModule)
        }

        val themeRepository: ThemeRepository =
            org.koin.java.KoinJavaComponent.get(ThemeRepository::class.java)

        themeRepository.applyTheme()
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/adapter/PlaylistAdapter.kt ====
package com.practicum.playlistmaker.presentation.adapter

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.practicum.playlistmaker.databinding.PlaylistItemBinding
import com.practicum.playlistmaker.domain.playlist.Playlist
import com.practicum.playlistmaker.presentation.viewholder.PlaylistViewHolder

class PlaylistAdapter(
    private val onPlaylistClick: (Playlist) -> Unit
) : RecyclerView.Adapter<PlaylistViewHolder>() {

    private val items = mutableListOf<Playlist>()

    fun submitList(list: List<Playlist>) {
        items.clear()
        items.addAll(list)
        notifyDataSetChanged()
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PlaylistViewHolder {
        val binding = PlaylistItemBinding.inflate(
            LayoutInflater.from(parent.context),
            parent,
            false
        )
        return PlaylistViewHolder(binding, onPlaylistClick)
    }

    override fun onBindViewHolder(holder: PlaylistViewHolder, position: Int) {
        holder.bind(items[position])
    }

    override fun getItemCount(): Int = items.size
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/adapter/TrackAdapter.kt ====
package com.practicum.playlistmaker.presentation.adapter

import android.annotation.SuppressLint
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.practicum.playlistmaker.databinding.RecordItemBinding
import com.practicum.playlistmaker.domain.track.Track
import com.practicum.playlistmaker.presentation.viewholder.TrackViewHolder

class TrackAdapter(
    private val onTrackClick: (Track) -> Unit,
    private val onTrackLongClick: (Track) -> Unit
) : RecyclerView.Adapter<TrackViewHolder>() {
    private val items = mutableListOf<Track>()

    @SuppressLint("NotifyDataSetChanged")
    fun submitList(newList: List<Track>) {
        items.clear()
        items.addAll(newList)
        notifyDataSetChanged()
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TrackViewHolder {
        val binding = RecordItemBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        )
        return TrackViewHolder(binding, onTrackClick, onTrackLongClick)
    }


    override fun onBindViewHolder(holder: TrackViewHolder, position: Int) {
        holder.bind(items[position])
    }

    override fun getItemCount() = items.size
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/settings/SingleLiveEvent.kt ====
package com.practicum.playlistmaker.presentation.settings

import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Observer
import java.util.concurrent.atomic.AtomicBoolean

class SingleLiveEvent<T> : MutableLiveData<T>() {
    private val pending = AtomicBoolean(false)

    override fun observe(owner: LifecycleOwner, observer: Observer<in T>) {
        super.observe(owner) { t ->
            if (pending.compareAndSet(true, false)) {
                observer.onChanged(t)
            }
        }
    }

    override fun setValue(t: T?) {
        pending.set(true)
        super.setValue(t)
    }
}
==== ./app/src/main/java/com/practicum/playlistmaker/presentation/settings/SettingsUiEvent.kt ====
package com.practicum.playlistmaker.presentation.settings

sealed class SettingsUiEvent {
    object OpenPracticumOffer : SettingsUiEvent()
    object SendToHelpdesk : SettingsUiEvent()
    object ShareApp : SettingsUiEvent()
    data class ShowError(val message: String) : SettingsUiEvent()
}
==== ./app/src/main/java/com/practicum/playlistmaker/presentation/settings/SettingsFragment.kt ====
package com.practicum.playlistmaker.presentation.settings

import android.app.ActivityOptions
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.core.net.toUri
import androidx.fragment.app.Fragment
import androidx.navigation.fragment.findNavController
import com.practicum.playlistmaker.R
import com.practicum.playlistmaker.databinding.FragmentSettingsBinding
import com.practicum.playlistmaker.presentation.main.MainActivity
import com.practicum.playlistmaker.presentation.theme.ThemeViewModel
import org.koin.androidx.viewmodel.ext.android.viewModel

class SettingsFragment : Fragment() {

    private var _binding: FragmentSettingsBinding? = null
    private val binding get() = _binding!!

    private val themeViewModel: ThemeViewModel by viewModel()
    private var themeInitialized = false

    companion object {
        private const val MIME_TYPE_TEXT_PLAIN = "text/plain"
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentSettingsBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        themeViewModel.state.observe(viewLifecycleOwner) { state ->
            if (!themeInitialized) {
                binding.themeSwitcher.isChecked = state.isDarkMode
                themeInitialized = true
            }
        }

        binding.themeSwitcher.setOnCheckedChangeListener { _, isChecked ->
            if (themeInitialized && isChecked != themeViewModel.state.value?.isDarkMode) {
                themeViewModel.switchTheme(isChecked)
            }
        }

        themeViewModel.uiEvent.observe(viewLifecycleOwner) { event ->
            when (event) {
                is SettingsUiEvent.OpenPracticumOffer -> openPracticumOffer()
                is SettingsUiEvent.SendToHelpdesk -> openHelpdeskEmail()
                is SettingsUiEvent.ShareApp -> shareApp()
                is SettingsUiEvent.ShowError -> Toast.makeText(
                    requireContext(),
                    event.message,
                    Toast.LENGTH_LONG
                ).show()
            }
        }

        binding.practicumOffer.setOnClickListener {
            themeViewModel.onPracticumOfferClicked()
        }

        binding.sendToHelpdesk.setOnClickListener {
            themeViewModel.onSendToHelpdeskClicked()
        }

        binding.shareApp.setOnClickListener {
            themeViewModel.onShareAppClicked()
        }
    }

    override fun onResume() {
        super.onResume()
        (activity as? MainActivity)?.showBottomNav()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    private fun openPracticumOffer() {
        val intent = Intent(Intent.ACTION_VIEW).apply {
            data = getString(R.string.practicum_license).toUri()
        }
        startSafe(intent)
    }

    private fun openHelpdeskEmail() {
        val email = getString(R.string.email)
        val subject = getString(R.string.email_subject)
        val body = getString(R.string.email_text)
        val uri = "mailto:$email?subject=${Uri.encode(subject)}&body=${Uri.encode(body)}"
        val intent = Intent(Intent.ACTION_SENDTO, uri.toUri())
        startSafe(intent)
    }

    private fun shareApp() {
        val intent = Intent(Intent.ACTION_SEND).apply {
            type = MIME_TYPE_TEXT_PLAIN
            putExtra(
                Intent.EXTRA_TEXT,
                getString(R.string.https_practicum_yandex_ru_android_developer)
            )
        }
        startSafe(Intent.createChooser(intent, null))
    }

    private fun startSafe(intent: Intent) {
        try {
            startActivity(intent)
        } catch (e: Exception) {
            Toast.makeText(
                requireContext(),
                getString(R.string.no_intent_handle),
                Toast.LENGTH_LONG
            ).show()
        }
    }
}
==== ./app/src/main/java/com/practicum/playlistmaker/presentation/media/MediaViewPagerAdapter.kt ====
package com.practicum.playlistmaker.presentation.media

import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentManager
import androidx.lifecycle.Lifecycle
import androidx.viewpager2.adapter.FragmentStateAdapter

class MediaViewPagerAdapter(
    fragmentManager: FragmentManager, lifecycle: Lifecycle, private val tabs: List<MediaTab>
) : FragmentStateAdapter(fragmentManager, lifecycle) {

    override fun getItemCount() = tabs.size

    override fun createFragment(position: Int): Fragment {
        return when (tabs[position]) {
            MediaTab.FAVORITES -> FavoritesFragment.newInstance()
            MediaTab.PLAYLISTS -> PlaylistsFragment.newInstance()
        }
    }
}
==== ./app/src/main/java/com/practicum/playlistmaker/presentation/media/PlaylistFragment.kt ====
package com.practicum.playlistmaker.presentation.media

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import android.widget.Toast
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.LinearLayoutManager
import com.bumptech.glide.Glide
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.practicum.playlistmaker.R
import com.practicum.playlistmaker.databinding.FragmentPlaylistBinding
import com.practicum.playlistmaker.domain.track.Track
import com.practicum.playlistmaker.presentation.adapter.TrackAdapter
import com.practicum.playlistmaker.presentation.main.MainActivity
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.koin.androidx.viewmodel.ext.android.viewModel
import java.io.File

class PlaylistFragment : Fragment() {

    private var _binding: FragmentPlaylistBinding? = null
    private val binding get() = _binding!!

    private var playlistId: Long = -1
    private val viewModel: PlaylistViewModel by viewModel()

    private lateinit var bottomSheetBehavior: BottomSheetBehavior<LinearLayout>

    private lateinit var trackAdapter: TrackAdapter

    private lateinit var bottomSheetDialog: BottomSheetDialog

    companion object {
        private const val ARG_PLAYLIST_ID = "playlistId"

        fun newInstance(playlistId: Long) = PlaylistFragment().apply {
            arguments = Bundle().apply {
                putLong(ARG_PLAYLIST_ID, playlistId)
            }
        }
    }

    private fun setupPlaylistMenu() {
        bottomSheetDialog = BottomSheetDialog(
            requireContext(),
            R.style.BottomSheetMenuTheme
        )

        val view = layoutInflater.inflate(R.layout.bottom_sheet_playlist_menu, null)
        bottomSheetDialog.setContentView(view)

        view.post {
            val screenHeight = resources.displayMetrics.heightPixels
            val desiredHeight = (screenHeight * 0.53).toInt()

            val parent =
                view.parent as ViewGroup

            parent.layoutParams = parent.layoutParams.apply {
                height = desiredHeight
            }
        }

        setupMenuContent(view)
        setupMenuClickListeners(view)

        binding.playlistHamburgerButton.setOnClickListener {
            showPlaylistMenu()
        }
    }

    private fun setupMenuContent(view: View) {
        viewModel.state.value.playlist?.let { playlist ->
            view.findViewById<TextView>(R.id.playlistMenuTitle).text = playlist.title

            val trackCountText = resources.getQuantityString(
                R.plurals.tracks_count,
                playlist.trackCount,
                playlist.trackCount
            )
            view.findViewById<TextView>(R.id.playlistMenuTrackCount).text = trackCountText

            loadMenuCover(playlist.coverUri, view.findViewById(R.id.playlistMenuCover))
        }
    }

    private fun loadMenuCover(coverUri: String?, imageView: ImageView) {
        if (!coverUri.isNullOrEmpty()) {
            try {
                val file = File(coverUri)
                if (file.exists()) {
                    Glide.with(requireContext())
                        .load(file)
                        .centerCrop()
                        .into(imageView)
                    return
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

        Glide.with(requireContext())
            .load(R.drawable.ic_no_artwork_image)
            .centerCrop()
            .into(imageView)
    }


    private fun setupMenuClickListeners(view: View) {
        view.findViewById<TextView>(R.id.menuShare).setOnClickListener {
            sharePlaylist()
            bottomSheetDialog.dismiss()
        }

        view.findViewById<TextView>(R.id.menuEdit).setOnClickListener {
            editPlaylist()
            bottomSheetDialog.dismiss()
        }

        view.findViewById<TextView>(R.id.menuDelete).setOnClickListener {
            deletePlaylist()
            bottomSheetDialog.dismiss()
        }
    }

    private fun showPlaylistMenu() {
        setupMenuContent(bottomSheetDialog.findViewById(android.R.id.content)!!)
        bottomSheetDialog.show()
    }
    private fun sharePlaylist() {
        // TODO: Реализовать функционал "Поделиться плейлистом"
        Toast.makeText(requireContext(), "Поделиться плейлистом", Toast.LENGTH_SHORT).show()
    }

    private fun editPlaylist() {
        // TODO: Реализовать редактирование плейлиста
        Toast.makeText(requireContext(), "Редактировать плейлист", Toast.LENGTH_SHORT).show()
    }

    private fun deletePlaylist() {
        Toast.makeText(requireContext(), "Удалить плейлист", Toast.LENGTH_SHORT).show()
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            playlistId = it.getLong(ARG_PLAYLIST_ID, -1)
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        _binding = FragmentPlaylistBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        binding.overlay.alpha = 0.6f

        binding.playlistBackButton.setOnClickListener {
            findNavController().popBackStack()
        }

        binding.playlistShareButton.setOnClickListener {
            // TODO: реализовать в будущем
        }

        setupRecyclerView()
        setupBottomSheet()
        observeViewModel()
        setupPlaylistMenu()

        if (playlistId != -1L) {
            viewModel.loadPlaylist(playlistId)
        }
    }

    private fun setupRecyclerView() {
        trackAdapter = TrackAdapter(
            onTrackClick = { track ->
                navigateToPlayer(track)
            },
            onTrackLongClick = { track ->
                showDeleteDialog(track)
            }
        )

        binding.playlistRecyclerView.apply {
            layoutManager = LinearLayoutManager(requireContext())
            adapter = trackAdapter
        }
    }

    private fun navigateToPlayer(track: Track) {
        (requireActivity() as? MainActivity)?.hideBottomNav()
        val bundle = Bundle().apply { putParcelable("track", track) }
        findNavController().navigate(
            R.id.action_playlistFragment_to_audioPlayerFragment,
            bundle
        )
    }

    private fun showDeleteDialog(track: Track) {
        MaterialAlertDialogBuilder(requireContext())
            .setTitle(getString(R.string.delete_track_title))
            .setMessage(getString(R.string.delete_track_message))
            .setNegativeButton(getString(R.string.no)) { dialog, _ ->
                dialog.dismiss()
            }
            .setPositiveButton(getString(R.string.yes)) { dialog, _ ->
                viewModel.deleteTrackFromPlaylist(track)
                dialog.dismiss()
            }
            .show()
    }

    private fun setupBottomSheet() {
        val bottomSheetContainer = binding.bottomSheet
        val screenHeight = resources.displayMetrics.heightPixels

        bottomSheetBehavior = BottomSheetBehavior.from(bottomSheetContainer).apply {
            isFitToContents = false
            expandedOffset = 0
            skipCollapsed = false

            maxHeight = screenHeight

            peekHeight = (screenHeight * 0.35).toInt()

            state = BottomSheetBehavior.STATE_HIDDEN
        }

        binding.overlay.isVisible = false

        setupBottomSheetListeners()
    }

    private fun setupBottomSheetListeners() {
        binding.overlay.setOnClickListener(null)
        binding.overlay.setOnTouchListener(null)
        binding.overlay.isClickable = false
        binding.overlay.isFocusable = false
        binding.overlay.isFocusableInTouchMode = false

        binding.dragHandle.setOnClickListener {
            val currentHasTracks = viewModel.state.value.tracks.isNotEmpty()
            if (currentHasTracks) {
                when (bottomSheetBehavior.state) {
                    BottomSheetBehavior.STATE_COLLAPSED -> {
                        bottomSheetBehavior.state = BottomSheetBehavior.STATE_EXPANDED
                    }
                    BottomSheetBehavior.STATE_EXPANDED -> {
                        bottomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED
                    }
                    else -> {
                        bottomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED
                    }
                }
            }
        }

        bottomSheetBehavior.addBottomSheetCallback(object :
            BottomSheetBehavior.BottomSheetCallback() {

            override fun onStateChanged(bottomSheet: View, newState: Int) {
                if (newState == BottomSheetBehavior.STATE_HIDDEN &&
                    viewModel.state.value.tracks.isNotEmpty()) {
                    bottomSheet.post {
                        bottomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED
                    }
                    return
                }

                when (newState) {
                    BottomSheetBehavior.STATE_COLLAPSED -> {
                        binding.overlay.isVisible = true
                        binding.overlay.alpha = 0.6f
                    }
                    BottomSheetBehavior.STATE_EXPANDED -> {
                        binding.overlay.isVisible = true
                        binding.overlay.alpha = 0.6f
                    }
                    BottomSheetBehavior.STATE_HIDDEN -> {
                        binding.overlay.isVisible = false
                    }
                }
            }

            override fun onSlide(bottomSheet: View, slideOffset: Float) {
                val hasTracksNow = viewModel.state.value.tracks.isNotEmpty()

                if (!hasTracksNow) {
                    binding.overlay.isVisible = false
                    return
                }

                when {
                    slideOffset >= 0 -> {
                        binding.overlay.isVisible = true
                        binding.overlay.alpha = 0.6f
                    }
                    slideOffset < 0 -> {
                        binding.overlay.isVisible = false
                    }
                }
            }
        })
    }

    private fun observeViewModel() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.state.collectLatest { state ->
                binding.progressBar.isVisible = state.isLoading
                binding.contentContainer.isVisible = !state.isLoading

                state.playlist?.let { playlist ->
                    binding.playlistTitle.text = playlist.title

                    if (!playlist.description.isNullOrBlank()) {
                        binding.playlistDescription.text = playlist.description
                        binding.playlistDescription.visibility = View.VISIBLE
                    } else {
                        binding.playlistDescription.visibility = View.GONE
                    }

                    loadPlaylistCover(playlist.coverUri)

                    binding.playlistTracksCount.text = resources.getQuantityString(
                        R.plurals.tracks_count, state.trackCount, state.trackCount
                    )

                    val minutesText = if (state.totalDurationMinutes == 0L) {
                        getString(R.string.zero_minutes)
                    } else {
                        resources.getQuantityString(
                            R.plurals.tracks_minutes,
                            state.totalDurationMinutes.toInt(),
                            state.totalDurationMinutes
                        )
                    }
                    binding.playlistMinutesCount.text = minutesText

                    trackAdapter.submitList(state.tracks)

                    updateBottomSheetVisibility(state.tracks)
                }
            }
        }
    }

    private fun updateBottomSheetVisibility(tracks: List<Track>) {
        if (!::bottomSheetBehavior.isInitialized) return

        val screenHeight = resources.displayMetrics.heightPixels
        val peekHeight = (screenHeight * 0.35).toInt()
        val hasTracks = tracks.isNotEmpty()

        bottomSheetBehavior.peekHeight = peekHeight

        if (hasTracks) {
            bottomSheetBehavior.isHideable = false
            bottomSheetBehavior.isDraggable = true

            bottomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED

            binding.overlay.isVisible = true
            binding.overlay.alpha = 0.6f
        } else {
            bottomSheetBehavior.isHideable = true
            bottomSheetBehavior.isDraggable = false
            bottomSheetBehavior.state = BottomSheetBehavior.STATE_HIDDEN
            binding.overlay.isVisible = false
        }

        binding.dragHandle.isVisible = hasTracks
        binding.dragHandle.isClickable = hasTracks
        binding.dragHandle.isEnabled = hasTracks
    }
    private fun loadPlaylistCover(coverUri: String?) {
        if (!coverUri.isNullOrEmpty()) {
            try {
                val file = File(coverUri)
                if (file.exists()) {
                    binding.playlistCover.scaleType = ImageView.ScaleType.CENTER_CROP
                    binding.playlistCover.setPadding(0, 0, 0, 0)

                    Glide.with(requireContext()).load(file).into(binding.playlistCover)
                    return
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

        loadDefaultCover()
    }

    private fun loadDefaultCover() {
        val paddingPx = (60 * resources.displayMetrics.density).toInt()
        binding.playlistCover.scaleType = ImageView.ScaleType.FIT_CENTER
        binding.playlistCover.setPadding(paddingPx, paddingPx, paddingPx, paddingPx)

        Glide.with(requireContext()).load(R.drawable.ic_no_artwork_image)
            .into(binding.playlistCover)
    }

    override fun onResume() {
        super.onResume()

        if (::bottomSheetBehavior.isInitialized) {
            val displayMetrics = resources.displayMetrics
            val peekHeight = (displayMetrics.heightPixels * 0.35).toInt()
            bottomSheetBehavior.peekHeight = peekHeight

            val hasTracks = viewModel.state.value.tracks.isNotEmpty()
            if (hasTracks) {
                if (bottomSheetBehavior.state == BottomSheetBehavior.STATE_HIDDEN) {
                    bottomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED
                    binding.overlay.isVisible = true
                    binding.overlay.alpha = 0.6f
                }
                bottomSheetBehavior.isHideable = false
                bottomSheetBehavior.isDraggable = true
            } else {
                bottomSheetBehavior.state = BottomSheetBehavior.STATE_HIDDEN
                binding.overlay.isVisible = false
                bottomSheetBehavior.isHideable = true
                bottomSheetBehavior.isDraggable = false
            }
        }

        (activity as? MainActivity)?.showBottomNav()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/media/MediaViewModel.kt ====
package com.practicum.playlistmaker.presentation.media

import androidx.lifecycle.ViewModel

class MediaViewModel : ViewModel() {
    val tabs = listOf(MediaTab.FAVORITES, MediaTab.PLAYLISTS)
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/media/PlaylistViewModel.kt ====
package com.practicum.playlistmaker.presentation.media

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.practicum.playlistmaker.domain.playlist.DeleteTrackFromPlaylistUseCase
import com.practicum.playlistmaker.domain.playlist.GetPlaylistByIdUseCase
import com.practicum.playlistmaker.domain.playlist.GetTracksForPlaylistUseCase
import com.practicum.playlistmaker.domain.playlist.Playlist
import com.practicum.playlistmaker.domain.track.Track
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

data class PlaylistScreenState(
    val playlist: Playlist? = null,
    val tracks: List<Track> = emptyList(),
    val isLoading: Boolean = false,
    val totalDurationMinutes: Long = 0,
    val trackCount: Int = 0
)

class PlaylistViewModel(
    private val getPlaylistByIdUseCase: GetPlaylistByIdUseCase,
    private val getTracksForPlaylistUseCase: GetTracksForPlaylistUseCase,
    private val deleteTrackFromPlaylistUseCase: DeleteTrackFromPlaylistUseCase
) : ViewModel() {

    private val _state = MutableStateFlow(PlaylistScreenState())
    val state: StateFlow<PlaylistScreenState> = _state.asStateFlow()

    fun loadPlaylist(playlistId: Long) {
        _state.value = _state.value.copy(isLoading = true)

        viewModelScope.launch {
            val playlist = getPlaylistByIdUseCase.execute(playlistId)
            val tracks = getTracksForPlaylistUseCase.execute(playlistId)

            val totalDurationMinutes = calculateTotalDuration(tracks)
            val trackCount = tracks.size

            _state.value = _state.value.copy(
                playlist = playlist,
                tracks = tracks,
                totalDurationMinutes = totalDurationMinutes,
                trackCount = trackCount,
                isLoading = false
            )
        }
    }

    fun deleteTrackFromPlaylist(track: Track) {
        viewModelScope.launch {
            _state.value.playlist?.let { playlist ->
                deleteTrackFromPlaylistUseCase.execute(playlist.id, track.trackId)
                loadPlaylist(playlist.id)
            }
        }
    }

    private fun calculateTotalDuration(tracks: List<Track>): Long {
        if (tracks.isEmpty()) return 0

        val totalMillis = tracks.sumOf { it.trackTimeMillis ?: 0L }
        return totalMillis / (1000 * 60)
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/media/PlaylistsViewModel.kt ====
package com.practicum.playlistmaker.presentation.media

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.practicum.playlistmaker.domain.playlist.GetPlaylistsUseCase
import com.practicum.playlistmaker.domain.playlist.Playlist
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class PlaylistsViewModel(
    private val getPlaylistsUseCase: GetPlaylistsUseCase
) : ViewModel() {

    private val _playlists = MutableStateFlow<List<Playlist>>(emptyList())
    val playlists: StateFlow<List<Playlist>> = _playlists.asStateFlow()

    fun loadPlaylists() {
        viewModelScope.launch {
            getPlaylistsUseCase.execute().collect { list ->
                _playlists.value = list
            }
        }
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/media/PlaylistsFragment.kt ====
package com.practicum.playlistmaker.presentation.media

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.GridLayoutManager
import com.practicum.playlistmaker.R
import com.practicum.playlistmaker.databinding.FragmentPlaylistsBinding
import com.practicum.playlistmaker.domain.playlist.Playlist
import com.practicum.playlistmaker.presentation.adapter.PlaylistAdapter
import com.practicum.playlistmaker.presentation.main.MainActivity
import com.practicum.playlistmaker.presentation.util.GridSpacingItemDecoration
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.koin.androidx.viewmodel.ext.android.viewModel


class PlaylistsFragment : Fragment() {

    private var _binding: FragmentPlaylistsBinding? = null
    private val binding get() = _binding!!

    private val viewModel: PlaylistsViewModel by viewModel()

    private lateinit var adapter: PlaylistAdapter

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        _binding = FragmentPlaylistsBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        adapter = PlaylistAdapter { playlist ->
            navigateToPlaylistFragment(playlist)
        }

        val spacing = resources.getDimensionPixelSize(R.dimen.grid_spacing_8)

        binding.playlistsItems.layoutManager = GridLayoutManager(requireContext(), 2)
        binding.playlistsItems.addItemDecoration(GridSpacingItemDecoration(spacing))

        binding.playlistsItems.adapter = adapter

        binding.createPlaylistButton.setOnClickListener {
            findNavController().navigate(
                R.id.action_mediaFragment_to_newPlaylistFragment
            )
        }

        observeViewModel()
        viewModel.loadPlaylists()
    }

    private fun observeViewModel() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.playlists.collectLatest { list ->
                adapter.submitList(list)
                updateEmptyState(list)
            }
        }
    }

    private fun updateEmptyState(playlists: List<Playlist>) {
        if (playlists.isEmpty()) {
            binding.emptyPlaylistImage.visibility = View.VISIBLE
            binding.mediaTab.visibility = View.VISIBLE
        } else {
            binding.emptyPlaylistImage.visibility = View.GONE
            binding.mediaTab.visibility = View.GONE
        }
    }

    private fun navigateToPlaylistFragment(playlist: Playlist) {
        val bundle = Bundle().apply {
            putLong("playlistId", playlist.id)
        }
        findNavController().navigate(
            R.id.action_mediaFragment_to_playlistFragment, bundle
        )
    }

    override fun onResume() {
        super.onResume()
        (activity as? MainActivity)?.showBottomNav()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    companion object {
        fun newInstance() = PlaylistsFragment()
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/media/NewPlaylistViewModel.kt ====
package com.practicum.playlistmaker.presentation.media

import android.net.Uri
import androidx.annotation.StringRes
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.practicum.playlistmaker.R
import com.practicum.playlistmaker.domain.playlist.CreatePlaylistUseCase
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

data class NewPlaylistScreenState(
    val title: String = "",
    val description: String = "",
    val coverUri: Uri? = null,
    val isCreateEnabled: Boolean = false,
    val isCreating: Boolean = false,
    @StringRes val error: Int? = null,
    val success: Boolean = false
)

class NewPlaylistViewModel(
    private val createPlaylistUseCase: CreatePlaylistUseCase
) : ViewModel() {

    private val _state = MutableStateFlow(NewPlaylistScreenState())
    val state: StateFlow<NewPlaylistScreenState> = _state.asStateFlow()

    fun onTitleChanged(title: String) {
        _state.update { it.copy(title = title, isCreateEnabled = title.isNotBlank()) }
    }

    fun onDescriptionChanged(description: String) {
        _state.update { it.copy(description = description) }
    }

    fun onCoverSelected(uri: Uri) {
        _state.update { it.copy(coverUri = uri) }
    }

    fun createPlaylist() {
        val current = _state.value
        if (current.title.isBlank()) {
            _state.update { it.copy(error = R.string.error_playlist_title_empty) }
            return
        }

        _state.update { it.copy(isCreating = true, error = null) }

        viewModelScope.launch {
            try {
                createPlaylistUseCase.execute(
                    title = current.title,
                    description = current.description,
                    coverUri = current.coverUri
                )
                _state.update { it.copy(isCreating = false, success = true) }
            } catch (e: Exception) {
                _state.update { it.copy(isCreating = false, error = R.string.unknown_error) }
            }
        }
    }

    private fun <T> MutableStateFlow<T>.update(block: (T) -> T) {
        value = block(value)
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/media/FavoritesFragment.kt ====
package com.practicum.playlistmaker.presentation.media

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.LinearLayoutManager
import com.practicum.playlistmaker.R
import com.practicum.playlistmaker.databinding.FragmentFavoritesBinding
import com.practicum.playlistmaker.domain.track.Track
import com.practicum.playlistmaker.presentation.adapter.TrackAdapter
import com.practicum.playlistmaker.presentation.main.MainActivity
import org.koin.androidx.viewmodel.ext.android.viewModel

class FavoritesFragment : Fragment() {

    private var _binding: FragmentFavoritesBinding? = null
    private val binding get() = _binding!!

    private val viewModel: FavoritesViewModel by viewModel()

    private lateinit var trackAdapter: TrackAdapter

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        _binding = FragmentFavoritesBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupRecyclerView()
        observeViewModel()
        viewModel.loadFavorites()
    }

    private fun setupRecyclerView() {
        trackAdapter = TrackAdapter(
            onTrackClick = { track ->
                (requireActivity() as MainActivity).hideBottomNav()
                val bundle = Bundle().apply { putParcelable("track", track) }
                findNavController().navigate(R.id.action_mediaFragment_to_audioPlayerFragment, bundle)
            },
            onTrackLongClick = { }
        )

        binding.favoritesItems.apply {
            layoutManager = LinearLayoutManager(requireContext())
            adapter = trackAdapter
        }
    }

    private fun observeViewModel() {
        viewModel.favorites.observe(viewLifecycleOwner) { tracks ->
            trackAdapter.submitList(tracks)
            updateEmptyState(tracks)
        }
    }

    private fun updateEmptyState(tracks: List<Track>) {
        if (tracks.isEmpty()) {
            binding.mediaIsEmptyImage.visibility = View.VISIBLE
            binding.mediaIsEmptyText.visibility = View.VISIBLE
        } else {
            binding.mediaIsEmptyImage.visibility = View.GONE
            binding.mediaIsEmptyText.visibility = View.GONE
        }
    }

    override fun onResume() {
        super.onResume()
        (activity as? MainActivity)?.showBottomNav()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    companion object {
        fun newInstance() = FavoritesFragment()
    }
}
==== ./app/src/main/java/com/practicum/playlistmaker/presentation/media/FavoritesViewModel.kt ====
package com.practicum.playlistmaker.presentation.media

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.practicum.playlistmaker.domain.favorites.GetFavoritesUseCase
import com.practicum.playlistmaker.domain.track.Track
import kotlinx.coroutines.launch

class FavoritesViewModel(
    private val getFavoritesUseCase: GetFavoritesUseCase
) : ViewModel() {

    private val _favorites = MutableLiveData<List<Track>>()
    val favorites: LiveData<List<Track>> = _favorites

    fun loadFavorites() {
        viewModelScope.launch {
            getFavoritesUseCase.execute().collect { list ->
                _favorites.value = list
            }
        }
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/media/MediaFragment.kt ====
package com.practicum.playlistmaker.presentation.media

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import com.google.android.material.tabs.TabLayoutMediator
import com.practicum.playlistmaker.R
import com.practicum.playlistmaker.databinding.FragmentMediaBinding
import org.koin.androidx.viewmodel.ext.android.viewModel

class MediaFragment : Fragment() {

    private var _binding: FragmentMediaBinding? = null
    private val binding get() = _binding!!

    private val viewModel: MediaViewModel by viewModel()

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentMediaBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        binding.viewPager.adapter =
            MediaViewPagerAdapter(childFragmentManager, viewLifecycleOwner.lifecycle, viewModel.tabs)

        TabLayoutMediator(binding.tabLayout, binding.viewPager) { tab, position ->
            tab.text = when (viewModel.tabs[position]) {
                MediaTab.FAVORITES -> getString(R.string.favourite_tracks)
                MediaTab.PLAYLISTS -> getString(R.string.playlists)
            }
        }.attach()

    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
==== ./app/src/main/java/com/practicum/playlistmaker/presentation/media/MediaTab.kt ====
package com.practicum.playlistmaker.presentation.media

enum class MediaTab {
    FAVORITES,
    PLAYLISTS
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/media/NewPlaylistFragment.kt ====
package com.practicum.playlistmaker.presentation.media

import android.Manifest
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.activity.addCallback
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.content.ContextCompat
import androidx.core.widget.addTextChangedListener
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.findNavController
import com.bumptech.glide.Glide
import com.bumptech.glide.load.resource.bitmap.CenterCrop
import com.bumptech.glide.load.resource.bitmap.RoundedCorners
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.practicum.playlistmaker.R
import com.practicum.playlistmaker.databinding.FragmentNewPlaylistBinding
import com.practicum.playlistmaker.presentation.main.MainActivity
import com.practicum.playlistmaker.presentation.util.Useful
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.koin.androidx.viewmodel.ext.android.viewModel

class NewPlaylistFragment : Fragment() {

    private var _binding: FragmentNewPlaylistBinding? = null
    private val binding get() = _binding!!

    private val viewModel: NewPlaylistViewModel by viewModel()

    private val pickCoverLauncher =
        registerForActivityResult(ActivityResultContracts.PickVisualMedia()) { uri ->
            if (uri != null) {
                viewModel.onCoverSelected(uri)
            }
        }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        _binding = FragmentNewPlaylistBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        setupListeners()
        observeViewModel()

        requireActivity().onBackPressedDispatcher.addCallback(viewLifecycleOwner) {
            handleBackPress()
        }

        (activity as? MainActivity)?.hideBottomNav()
    }

    private fun setupListeners() {
        binding.playlistTitle.addTextChangedListener {
            viewModel.onTitleChanged(it.toString())
        }

        binding.playlistDescription.addTextChangedListener {
            viewModel.onDescriptionChanged(it.toString())
        }

        binding.newPlaylistImage.setOnClickListener {
            if (hasGalleryPermission()) {
                pickCoverLauncher.launch(
                    PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly)
                )
            } else {
                Toast.makeText(
                    requireContext(), getString(R.string.no_photo_access), Toast.LENGTH_SHORT
                ).show()
            }
        }

        binding.createPlaylistButton.setOnClickListener {
            viewModel.createPlaylist()
        }

        binding.newPlayListBack.setOnClickListener {
            handleBackPress()
        }
    }

    private fun observeViewModel() {
        lifecycleScope.launch {
            viewModel.state.collectLatest { state ->
                binding.createPlaylistButton.isEnabled = state.isCreateEnabled

                state.coverUri?.let { uri ->
                    Glide.with(requireContext()).load(uri).transform(
                        CenterCrop(), RoundedCorners(Useful.dpToPx(8f, requireContext()))
                    ).into(binding.playlistCover)
                    binding.addCoverIcon.visibility = View.GONE
                }

                if (state.success) {
                    val message = getString(R.string.playlist_created, state.title)
                    Toast.makeText(requireContext(), message, Toast.LENGTH_SHORT).show()
                    findNavController().navigateUp()
                }

                state.error?.let { error ->
                    MaterialAlertDialogBuilder(requireContext()).setTitle(getString(R.string.Error))
                        .setMessage(error).setPositiveButton(getString(R.string.okay), null).show()
                }
            }
        }
    }

    private fun handleBackPress() {
        val currentState = viewModel.state.value
        val hasUnsaved =
            currentState.title.isNotBlank() || currentState.description.isNotBlank() || currentState.coverUri != null

        if (hasUnsaved) {
            MaterialAlertDialogBuilder(requireContext()).setTitle(getString(R.string.abort_create_playlist))
                .setMessage(getString(R.string.all_data_will_be_lost))
                .setNegativeButton(getString(R.string.cancel_btn)) { dialog, _ -> dialog.dismiss() }
                .setPositiveButton(getString(R.string.finish_btn)) { _, _ ->
                    findNavController().navigateUp()
                }.show()
        } else {
            findNavController().navigateUp()
        }
    }

    private fun hasGalleryPermission(): Boolean {
        val permission = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            Manifest.permission.READ_MEDIA_IMAGES
        } else {
            Manifest.permission.READ_EXTERNAL_STORAGE
        }

        return ContextCompat.checkSelfPermission(
            requireContext(), permission
        ) == PackageManager.PERMISSION_GRANTED
    }

    override fun onResume() {
        super.onResume()
        (activity as? MainActivity)?.hideBottomNav()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/util/Useful.kt ====
package com.practicum.playlistmaker.presentation.util

import android.content.Context
import android.util.TypedValue

class Useful {
    companion object {
        fun dpToPx(dp: Float, context: Context): Int {
            return TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP, dp, context.resources.displayMetrics
            ).toInt()
        }
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/util/GridSpacingItemDecoration.kt ====
package com.practicum.playlistmaker.presentation.util

import android.graphics.Rect
import android.view.View
import androidx.recyclerview.widget.RecyclerView

class GridSpacingItemDecoration(
    private val spacingPx: Int
) : RecyclerView.ItemDecoration() {

    override fun getItemOffsets(
        outRect: Rect,
        view: View,
        parent: RecyclerView,
        state: RecyclerView.State
    ) {
        outRect.left = spacingPx
        outRect.right = spacingPx
        outRect.bottom = spacingPx
        outRect.top = spacingPx
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/util/IntentExtenstions.kt ====
package com.practicum.playlistmaker.presentation.util

import android.content.Intent
import android.os.Build
import android.os.Parcelable

inline fun <reified T : Parcelable> Intent.parcelableExtra(key: String): T? {
    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
        getParcelableExtra(key, T::class.java)
    } else {
        @Suppress("DEPRECATION") getParcelableExtra(key)
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/search/SearchFragment.kt ====
package com.practicum.playlistmaker.presentation.search

import android.content.Context.INPUT_METHOD_SERVICE
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.inputmethod.EditorInfo
import android.view.inputmethod.InputMethodManager
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.bottomnavigation.BottomNavigationView
import com.practicum.playlistmaker.R
import com.practicum.playlistmaker.databinding.EmptySearchBinding
import com.practicum.playlistmaker.databinding.FragmentSearchBinding
import com.practicum.playlistmaker.databinding.NoInternetBinding
import com.practicum.playlistmaker.databinding.SearchHistoryBinding
import com.practicum.playlistmaker.domain.track.Track
import com.practicum.playlistmaker.presentation.adapter.TrackAdapter
import com.practicum.playlistmaker.presentation.main.MainActivity
import kotlinx.coroutines.flow.collectLatest
import org.koin.androidx.viewmodel.ext.android.viewModel

class SearchFragment : Fragment() {

    private var _binding: FragmentSearchBinding? = null
    private val binding get() = _binding!!

    private val viewModel: SearchViewModel by viewModel()

    private lateinit var adapter: TrackAdapter
    private lateinit var historyAdapter: TrackAdapter

    private lateinit var emptySearchBinding: EmptySearchBinding
    private lateinit var noInternetBinding: NoInternetBinding
    private lateinit var searchHistoryBinding: SearchHistoryBinding

    private var wasSearchFocused = false

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        _binding = FragmentSearchBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        initStubBindings()
        initAdapters()
        observeViewModel()
        setupListeners()
        setupKeyboardListener()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    private fun initStubBindings() {
        emptySearchBinding = EmptySearchBinding.bind(binding.stubEmptySearchInc.root)
        noInternetBinding = NoInternetBinding.bind(binding.stubNoInternetInc.root)
        searchHistoryBinding = SearchHistoryBinding.bind(binding.stubSearchHistoryInc.root)
    }

    private fun initAdapters() {
        adapter = TrackAdapter(
            onTrackClick = { track ->
                viewModel.onTrackClicked(track) {
                    openPlayer(it)
                }
            },
            onTrackLongClick = { }
        )

        binding.rcTrackData.layoutManager = LinearLayoutManager(requireContext())
        binding.rcTrackData.adapter = adapter

        historyAdapter = TrackAdapter(
            onTrackClick = { track ->
                viewModel.addTrackToHistory(track)
                openPlayer(track)
            },
            onTrackLongClick = { }
        )
        searchHistoryBinding.rcTrackDataHistory.layoutManager =
            LinearLayoutManager(requireContext())
        searchHistoryBinding.rcTrackDataHistory.adapter = historyAdapter
    }

    private fun observeViewModel() {
        viewLifecycleOwner.lifecycleScope.launchWhenStarted {
            viewModel.state.collectLatest { state ->
                adapter.submitList(state.tracks)
                historyAdapter.submitList(state.history)

                binding.stubEmptySearchInc.root.isVisible =
                    state.tracks.isEmpty() && state.hasSearched
                binding.stubNoInternetInc.root.isVisible = state.isError

                binding.progressBar.isVisible = state.isLoading
                updateSearchHistoryVisibility(state.history)
            }
        }
    }

    private fun setupListeners() {
        binding.clearButton.setOnClickListener {
            binding.searchEditText.text?.clear()
            viewModel.clearSearchResults()
            viewModel.loadHistory()
            binding.searchEditText.requestFocus()
            hideKeyboard()
        }

        binding.searchEditText.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun afterTextChanged(s: Editable?) {}

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                val query = s?.toString() ?: ""
                binding.clearButton.isVisible = query.isNotEmpty()
                viewModel.onQueryChanged(query)
            }
        })

        binding.searchEditText.setOnFocusChangeListener { _, hasFocus ->
            if (hasFocus) {
                viewModel.loadHistory()
                updateSearchHistoryVisibility(viewModel.state.value.history)
            }
        }

        binding.searchEditText.setOnEditorActionListener { _, actionId, _ ->
            if (actionId == EditorInfo.IME_ACTION_DONE) {
                val query = binding.searchEditText.text.toString()
                if (query.isNotBlank()) {
                    viewModel.onSearchDone(query)
                    hideKeyboard()
                }
                true
            } else false
        }

        noInternetBinding.buttonRetry.setOnClickListener {
            val query = binding.searchEditText.text.toString()
            if (query.isNotBlank()) {
                binding.progressBar.isVisible = true
                viewModel.onSearchDone(query)
            }
        }

        searchHistoryBinding.buttonClearSearchHistory.setOnClickListener {
            viewModel.clearHistory()
        }
    }

    private fun updateSearchHistoryVisibility(history: List<Track>) {
        val isEmptyQuery = binding.searchEditText.text.isEmpty()
        val hasFocus = binding.searchEditText.hasFocus()

        val showHistory = hasFocus && isEmptyQuery && history.isNotEmpty()
        searchHistoryBinding.root.isVisible = showHistory
        searchHistoryBinding.rcTrackDataHistory.isVisible = showHistory
        searchHistoryBinding.buttonClearSearchHistory.isVisible = showHistory
    }

    private fun hideKeyboard() {
        val imm = requireContext().getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager
        imm.hideSoftInputFromWindow(binding.searchEditText.windowToken, 0)
    }

    private fun openPlayer(track: Track) {
        (requireActivity() as? MainActivity)?.hideBottomNav()
        val bundle = Bundle().apply { putParcelable("track", track) }
        findNavController().navigate(R.id.action_searchFragment_to_audioPlayerFragment, bundle)
    }

    private fun setupKeyboardListener() {
        val rootView = requireActivity().findViewById<View>(R.id.container_view)
        rootView.viewTreeObserver.addOnGlobalLayoutListener {
            if (!isAdded) return@addOnGlobalLayoutListener
            val rect = android.graphics.Rect()
            rootView.getWindowVisibleDisplayFrame(rect)
            val screenHeight = rootView.rootView.height
            val keypadHeight = screenHeight - rect.bottom

            val bottomNav =
                requireActivity().findViewById<BottomNavigationView>(R.id.bottomNavigationView)
            bottomNav.isVisible = keypadHeight < screenHeight * 0.15
        }
    }

    override fun onPause() {
        super.onPause()
        wasSearchFocused = binding.searchEditText.hasFocus()
    }

    override fun onResume() {
        super.onResume()
        if (wasSearchFocused) {
            binding.searchEditText.requestFocus()
            val imm = requireContext().getSystemService(InputMethodManager::class.java)
            imm.showSoftInput(binding.searchEditText, InputMethodManager.SHOW_IMPLICIT)
        }
        (activity as? MainActivity)?.showBottomNav()
    }
}
==== ./app/src/main/java/com/practicum/playlistmaker/presentation/search/SearchViewModel.kt ====
package com.practicum.playlistmaker.presentation.search

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.practicum.playlistmaker.domain.history.AddTrackToHistoryUseCase
import com.practicum.playlistmaker.domain.history.ClearSearchHistoryUseCase
import com.practicum.playlistmaker.domain.history.GetSearchHistoryUseCase
import com.practicum.playlistmaker.domain.track.SearchTracksUseCase
import com.practicum.playlistmaker.domain.track.Track
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch

class SearchViewModel(
    private val searchTracksUseCase: SearchTracksUseCase,
    private val getHistoryUseCase: GetSearchHistoryUseCase,
    private val addTrackUseCase: AddTrackToHistoryUseCase,
    private val clearHistoryUseCase: ClearSearchHistoryUseCase
) : ViewModel() {

    private var searchFlowJob: Job? = null
    private var clickJob: Job? = null
    private val CLICK_DEBOUNCE_DELAY = 500L

    private val _state = MutableStateFlow(SearchScreenState())
    val state: StateFlow<SearchScreenState> = _state.asStateFlow()

    private var searchJob: Job? = null

    companion object {
        private const val SEARCH_DEBOUNCE_DELAY = 500L
    }

    init {
        loadHistory()
    }

    fun onQueryChanged(query: String) {
        if (query.isBlank()) {
            searchJob?.cancel()
            _state.value = _state.value.copy(
                tracks = emptyList(), hasSearched = false, isError = false, isLoading = false
            )
            loadHistory()
            return
        }

        searchJob?.cancel()
        searchJob = viewModelScope.launch {
            delay(SEARCH_DEBOUNCE_DELAY)
            searchTracks(query)
        }
    }

    fun onSearchDone(query: String) {
        searchJob?.cancel()
        _state.value = _state.value.copy(isLoading = true)
        searchTracks(query)
    }

    private fun searchTracks(query: String) {
        searchFlowJob?.cancel()

        _state.value = _state.value.copy(isLoading = true)

        searchFlowJob = searchTracksUseCase.execute(query).catch {
                _state.value = _state.value.copy(
                    tracks = emptyList(), hasSearched = true, isError = true, isLoading = false
                )
            }.onEach { tracks ->
                _state.value = _state.value.copy(
                    tracks = tracks, hasSearched = true, isError = false, isLoading = false
                )
            }.launchIn(viewModelScope)
    }

    fun loadHistory() {
        _state.value = _state.value.copy(
            history = getHistoryUseCase.execute()
        )
    }

    fun addTrackToHistory(track: Track) {
        addTrackUseCase.execute(track)
        loadHistory()
    }

    fun clearHistory() {
        clearHistoryUseCase.execute()
        loadHistory()
    }

    fun clearSearchResults() {
        searchJob?.cancel()
        _state.value = _state.value.copy(
            tracks = emptyList(), hasSearched = false, isError = false
        )
        loadHistory()
    }


    fun onTrackClicked(
        track: Track, openPlayer: (Track) -> Unit
    ) {
        clickJob?.cancel()
        clickJob = viewModelScope.launch {
            delay(CLICK_DEBOUNCE_DELAY)
            addTrackToHistory(track)
            openPlayer(track)
        }
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/search/SearchScreenState.kt ====
package com.practicum.playlistmaker.presentation.search

import com.practicum.playlistmaker.domain.track.Track

data class SearchScreenState(
    val tracks: List<Track> = emptyList(),
    val history: List<Track> = emptyList(),
    val isError: Boolean = false,
    val hasSearched: Boolean = false,
    val isLoading: Boolean = false
)
==== ./app/src/main/java/com/practicum/playlistmaker/presentation/main/MainActivity.kt ====
package com.practicum.playlistmaker.presentation.main

import android.Manifest
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.util.Log
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.core.view.isVisible
import androidx.navigation.fragment.NavHostFragment
import androidx.navigation.ui.setupWithNavController
import com.practicum.playlistmaker.R
import com.practicum.playlistmaker.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding

    private lateinit var permissionLauncher: ActivityResultLauncher<String>

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        initPermissionLauncher()
        checkGalleryPermission()

        val navHostFragment =
            supportFragmentManager.findFragmentById(R.id.container_view) as? NavHostFragment
        val navController = navHostFragment?.navController

        navController?.let {
            binding.bottomNavigationView.setupWithNavController(it)

            navController.addOnDestinationChangedListener { _, destination, _ ->
                when (destination.id) {
                    R.id.audioPlayerFragment,
                    R.id.newPlaylistFragment,
                    R.id.playlistFragment -> hideBottomNav()
                    else -> showBottomNav()
                }
            }
        }
    }

    private fun initPermissionLauncher() {
        permissionLauncher =
            registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted ->
                if (granted) {
                    Log.d("PERMISSION", "Доступ к фото разрешен")
                } else {
                    Log.d("PERMISSION", "Доступ к фото запрещен")
                }
            }
    }

    private fun checkGalleryPermission() {
        val permission = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            Manifest.permission.READ_MEDIA_IMAGES
        } else {
            Manifest.permission.READ_EXTERNAL_STORAGE
        }

        val granted = ContextCompat.checkSelfPermission(
            this, permission
        ) == PackageManager.PERMISSION_GRANTED

        if (!granted) {
            permissionLauncher.launch(permission)
        }
    }

    fun hideBottomNav() {
        binding.bottomNavigationView.isVisible = false

    }

    fun showBottomNav() {
        binding.bottomNavigationView.isVisible = true
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/viewholder/PlaylistBottomSheetViewHolder.kt ====
package com.practicum.playlistmaker.presentation.viewholder

import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.bumptech.glide.load.MultiTransformation
import com.bumptech.glide.load.resource.bitmap.CenterCrop
import com.bumptech.glide.load.resource.bitmap.RoundedCorners
import com.practicum.playlistmaker.R
import com.practicum.playlistmaker.databinding.BottomSheetPlaylistItemBinding
import com.practicum.playlistmaker.domain.playlist.Playlist
import com.practicum.playlistmaker.presentation.util.Useful
import java.io.File

class PlaylistBottomSheetViewHolder(
    private val binding: BottomSheetPlaylistItemBinding
) : RecyclerView.ViewHolder(binding.root) {

    fun bind(item: Playlist) {
        binding.playlistTitle.text = item.title

        val tracksCount = item.trackCount
        binding.tracksCount.text = itemView.context.resources.getQuantityString(
            R.plurals.tracks_count,
            tracksCount,
            tracksCount
        )

        val radius = Useful.dpToPx(2f, itemView.context)

        if (!item.coverUri.isNullOrEmpty()) {
            try {
                val file = File(item.coverUri)
                if (file.exists()) {
                    Glide.with(itemView.context).load(file)
                        .placeholder(R.drawable.ic_no_artwork_image)
                        .transform(MultiTransformation(CenterCrop(), RoundedCorners(radius)))
                        .into(binding.playlistCover)
                } else {
                    loadDefaultCover(radius)
                }
            } catch (e: Exception) {
                e.printStackTrace()
                loadDefaultCover(radius)
            }
        } else {
            loadDefaultCover(radius)
        }
    }

    private fun loadDefaultCover(radius: Int) {
        Glide.with(itemView.context).load(R.drawable.ic_no_artwork_image)
            .transform(MultiTransformation(CenterCrop(), RoundedCorners(radius)))
            .into(binding.playlistCover)
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/viewholder/TrackViewHolder.kt ====
package com.practicum.playlistmaker.presentation.viewholder

import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.bumptech.glide.load.resource.bitmap.RoundedCorners
import com.practicum.playlistmaker.R
import com.practicum.playlistmaker.databinding.RecordItemBinding
import com.practicum.playlistmaker.domain.track.Track
import com.practicum.playlistmaker.presentation.util.Useful

class TrackViewHolder(
    private val binding: RecordItemBinding,
    private val onTrackClick: (Track) -> Unit,
    private val onTrackLongClick: (Track) -> Unit
) : RecyclerView.ViewHolder(binding.root) {
    fun bind(item: Track) {
        binding.trackName.text = item.trackName
        binding.artistsName.text = item.artistsName
        binding.trackTime.text = item.trackTime

        Glide.with(itemView).load(item.artworkUrl100).placeholder(R.drawable.ic_no_artwork_image)
            .fitCenter().transform(RoundedCorners(Useful.dpToPx(2f, itemView.context)))
            .into(binding.artworkImage)

        itemView.setOnClickListener {
            onTrackClick(item)
        }

        itemView.setOnLongClickListener {
            onTrackLongClick(item)
            true
        }
    }
}
==== ./app/src/main/java/com/practicum/playlistmaker/presentation/viewholder/PlaylistViewHolder.kt ====
package com.practicum.playlistmaker.presentation.viewholder

import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.bumptech.glide.load.MultiTransformation
import com.bumptech.glide.load.resource.bitmap.CenterCrop
import com.bumptech.glide.load.resource.bitmap.RoundedCorners
import com.practicum.playlistmaker.R
import com.practicum.playlistmaker.databinding.PlaylistItemBinding
import com.practicum.playlistmaker.domain.playlist.Playlist
import com.practicum.playlistmaker.presentation.util.Useful
import java.io.File

class PlaylistViewHolder(
    private val binding: PlaylistItemBinding,
    private val onPlaylistClick: (Playlist) -> Unit
) : RecyclerView.ViewHolder(binding.root) {

    fun bind(item: Playlist) {
        binding.playlistTitle.text = item.title

        val tracksCount = item.trackCount
        binding.tracksCount.text = itemView.context.resources.getQuantityString(
            R.plurals.tracks_count,
            tracksCount,
            tracksCount
        )

        val radius = Useful.dpToPx(8f, itemView.context)

        if (!item.coverUri.isNullOrEmpty()) {
            try {
                val file = File(item.coverUri)
                if (file.exists()) {
                    Glide.with(itemView.context).load(file)
                        .placeholder(R.drawable.ic_no_artwork_image)
                        .transform(MultiTransformation(CenterCrop(), RoundedCorners(radius)))
                        .into(binding.playlistCover)
                } else {
                    loadDefaultCover(radius)
                }
            } catch (e: Exception) {
                e.printStackTrace()
                loadDefaultCover(radius)
            }
        } else {
            loadDefaultCover(radius)
        }

        itemView.setOnClickListener {
            onPlaylistClick(item)
        }
    }

    private fun loadDefaultCover(radius: Int) {
        Glide.with(itemView.context).load(R.drawable.ic_no_artwork_image)
            .transform(MultiTransformation(CenterCrop(), RoundedCorners(radius)))
            .into(binding.playlistCover)
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/player/AudioPlayerScreenState.kt ====
package com.practicum.playlistmaker.presentation.player

import com.practicum.playlistmaker.domain.track.Track

data class AudioPlayerScreenState(
    val track: Track? = null,
    val isPlaying: Boolean = false,
    val currentPosition: Int = 0,
    val isFavorite: Boolean = false
)==== ./app/src/main/java/com/practicum/playlistmaker/presentation/player/AudioPlayerFragment.kt ====
package com.practicum.playlistmaker.presentation.player

import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.LinearLayout
import android.widget.Toast
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.LinearLayoutManager
import com.bumptech.glide.Glide
import com.bumptech.glide.load.resource.bitmap.RoundedCorners
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.practicum.playlistmaker.R
import com.practicum.playlistmaker.databinding.FragmentAudioPlayerBinding
import com.practicum.playlistmaker.domain.track.Track
import com.practicum.playlistmaker.presentation.main.MainActivity
import com.practicum.playlistmaker.presentation.util.Useful
import org.koin.androidx.viewmodel.ext.android.viewModel

class AudioPlayerFragment : Fragment() {

    private var _binding: FragmentAudioPlayerBinding? = null
    private val binding get() = _binding!!

    private val viewModel: AudioPlayerViewModel by viewModel()

    private var track: Track? = null

    private lateinit var bottomSheetBehavior: BottomSheetBehavior<LinearLayout>

    private lateinit var adapter: PlaylistBottomSheetAdapter

    private var savedBottomSheetState: Int? = null
    private var savedOverlayVisible: Boolean = false

    private var returningFromNewPlaylist: Boolean = false

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            track = it.getParcelable(ARG_TRACK)
        }

        savedInstanceState?.let {
            savedBottomSheetState =
                it.getInt(KEY_BOTTOM_SHEET_STATE, BottomSheetBehavior.STATE_HIDDEN)
            savedOverlayVisible = it.getBoolean(KEY_OVERLAY_VISIBLE, false)
            returningFromNewPlaylist = it.getBoolean(KEY_RETURNING_FROM_NEW_PLAYLIST, false)
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        _binding = FragmentAudioPlayerBinding.inflate(inflater, container, false)
        binding.audBackButton.setOnClickListener {
            findNavController().popBackStack()
        }
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        (requireActivity() as? MainActivity)?.hideBottomNav()

        binding.audBackButton.setOnClickListener {
            findNavController().popBackStack()
        }

        if (track == null) {
            track = arguments?.getParcelable(ARG_TRACK)
            if (track == null && savedInstanceState != null) {
                track = savedInstanceState.getParcelable(ARG_TRACK)
            }
            if (track == null) {
                binding.root.post {
                    findNavController().popBackStack()
                }
                return
            }
        }

        viewModel.setTrack(track!!)
        observeViewModel()
        setupPlayerButtons()
        setupFavoriteButton()
        setupBottomSheet()
        restoreBottomSheetState()
    }

    private fun restoreBottomSheetState() {
        if (returningFromNewPlaylist) {
            savedBottomSheetState = BottomSheetBehavior.STATE_HIDDEN
            savedOverlayVisible = false
            returningFromNewPlaylist = false

            binding.root.post {
                binding.overlay.isVisible = false
            }
        }

        savedBottomSheetState?.let { savedState ->
            if (isValidBottomSheetState(savedState)) {
                binding.root.post {
                    if (::bottomSheetBehavior.isInitialized && bottomSheetBehavior.state != savedState) {
                        try {
                            bottomSheetBehavior.state = savedState
                        } catch (e: Exception) {
                            Log.e("AudioPlayer", "Error restoring bottom sheet state", e)
                        }
                    }
                }
            } else {
                savedBottomSheetState = BottomSheetBehavior.STATE_HIDDEN
                binding.root.post {
                    if (::bottomSheetBehavior.isInitialized) {
                        bottomSheetBehavior.state = BottomSheetBehavior.STATE_HIDDEN
                    }
                    binding.overlay.isVisible = false
                }
            }
        }

        if (savedOverlayVisible && savedBottomSheetState != BottomSheetBehavior.STATE_HIDDEN) {
            binding.root.post {
                binding.overlay.isVisible = true
                binding.overlay.alpha = 0.6f
            }
        }
    }


    private fun isValidBottomSheetState(state: Int): Boolean {
        return state == BottomSheetBehavior.STATE_HIDDEN || state == BottomSheetBehavior.STATE_COLLAPSED || state == BottomSheetBehavior.STATE_EXPANDED || state == BottomSheetBehavior.STATE_HALF_EXPANDED || state == BottomSheetBehavior.STATE_DRAGGING
    }


    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        track?.let {
            outState.putParcelable(ARG_TRACK, it)
        }
        viewModel.savePlaybackState()

        val stateToSave = if (::bottomSheetBehavior.isInitialized) {
            val currentState = bottomSheetBehavior.state
            if (isValidBottomSheetState(currentState) && currentState != BottomSheetBehavior.STATE_SETTLING) {
                currentState
            } else {
                savedBottomSheetState ?: BottomSheetBehavior.STATE_HIDDEN
            }
        } else {
            savedBottomSheetState ?: BottomSheetBehavior.STATE_HIDDEN
        }

        outState.putInt(KEY_BOTTOM_SHEET_STATE, stateToSave)
        outState.putBoolean(KEY_OVERLAY_VISIBLE, binding.overlay.isVisible)
        outState.putBoolean(KEY_RETURNING_FROM_NEW_PLAYLIST, returningFromNewPlaylist)
    }

    private fun observeViewModel() {
        viewModel.state.observe(viewLifecycleOwner) { state ->
            state.track?.let { track ->
                binding.mainAlbumText.text = track.trackName ?: "-"
                binding.artistName.text = track.artistsName ?: "-"
                binding.audAlbumNameValue.text = track.collectionName ?: "-"
                binding.audYearValue.text = track.releaseYear ?: "-"
                binding.audGenreValue.text = track.primaryGenreName ?: "-"
                binding.audCountryValue.text = track.country ?: "-"

                Glide.with(requireContext()).load(track.getConvertArtwork())
                    .placeholder(R.drawable.ic_no_artwork_image)
                    .transform(RoundedCorners(Useful.dpToPx(8f, requireContext())))
                    .into(binding.songPoster)
            }

            binding.currentTrackTime.text = formatTime(state.currentPosition)
            binding.audPlayButton.setImageResource(
                if (state.isPlaying) R.drawable.btn_aud_pause
                else R.drawable.btn_aud_play
            )

            binding.audFavoriteButton.setImageResource(
                if (state.isFavorite) R.drawable.btn_aud_like_true
                else R.drawable.btn_aud_like_false
            )
        }

        viewModel.addTrackStatus.observe(viewLifecycleOwner) { status ->
            status?.let {
                when (it) {
                    is AddTrackStatus.Success -> {
                        Toast.makeText(
                            requireContext(),
                            getString(R.string.added_to_playlist, it.playlistName),
                            Toast.LENGTH_SHORT
                        ).show()
                        viewModel.resetAddTrackStatus()
                    }

                    is AddTrackStatus.AlreadyExists -> {
                        Toast.makeText(
                            requireContext(),
                            getString(R.string.allready_exists_in_playlist, it.playlistName),
                            Toast.LENGTH_SHORT
                        ).show()
                        viewModel.resetAddTrackStatus()
                    }

                    is AddTrackStatus.Error -> {
                        Toast.makeText(
                            requireContext(),
                            getString(R.string.error, it.message),
                            Toast.LENGTH_SHORT
                        ).show()
                        viewModel.resetAddTrackStatus()
                    }
                }
            }
        }

        viewModel.shouldCloseBottomSheet.observe(viewLifecycleOwner) { shouldClose ->
            if (shouldClose == true) {
                hideBottomSheet()
                viewModel.resetShouldCloseBottomSheet()
            }
        }
    }

    private fun setupPlayerButtons() {
        binding.audPlayButton.setOnClickListener {
            val isPlaying = viewModel.state.value?.isPlaying ?: false
            if (isPlaying) viewModel.pausePlayer()
            else viewModel.startPlayer()
        }
    }

    private fun setupFavoriteButton() {
        binding.audFavoriteButton.setOnClickListener {
            viewModel.toggleFavorite()
        }
    }

    private fun formatTime(ms: Int): String {
        val seconds = ms / 1000
        val minutes = seconds / 60
        val remainingSeconds = seconds % 60
        return String.format("%02d:%02d", minutes, remainingSeconds)
    }

    override fun onPause() {
        super.onPause()
        if (!requireActivity().isChangingConfigurations) {
            viewModel.state.value?.isPlaying?.let { isPlaying ->
                if (isPlaying) {
                    viewModel.pausePlayer()
                }
            }
        }
    }

    override fun onStop() {
        super.onStop()
        if (!requireActivity().isChangingConfigurations) {
            viewModel.savePlaybackState()
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        if (!requireActivity().isChangingConfigurations) {
            (requireActivity() as? MainActivity)?.showBottomNav()
        }
        _binding = null
    }

    override fun onResume() {
        super.onResume()
        returningFromNewPlaylist = false
    }

    private fun setupBottomSheet() {
        val bottomSheetContainer = binding.bottomSheet
        val overlay = binding.overlay
        val recyclerView = binding.playlistRecyclerView
        val dragHandle = binding.dragHandle

        recyclerView.layoutManager = LinearLayoutManager(requireContext())
        adapter = PlaylistBottomSheetAdapter(mutableListOf()) { playlist ->
            track?.let { viewModel.addTrackToPlaylist(playlist, it) }
        }
        recyclerView.adapter = adapter

        viewModel.playlists.observe(viewLifecycleOwner) { playlists ->
            adapter.update(playlists)
        }

        val displayMetrics = resources.displayMetrics
        val screenHeight = displayMetrics.heightPixels
        val peekHeightPx = (screenHeight * 0.40).toInt()



        bottomSheetBehavior = BottomSheetBehavior.from(bottomSheetContainer).apply {
            state = BottomSheetBehavior.STATE_HIDDEN
            peekHeight = peekHeightPx
            isHideable = true
            isDraggable = true
            isFitToContents = false
            halfExpandedRatio = 0.40f
            expandedOffset = 0
            skipCollapsed = false
        }

        hideBottomSheet()

        binding.audAddToPlaylist.setOnClickListener {
            toggleBottomSheet()
        }

        overlay.setOnClickListener {
            hideBottomSheet()
        }

        dragHandle.setOnClickListener {
            when (bottomSheetBehavior.state) {
                BottomSheetBehavior.STATE_COLLAPSED -> {
                    bottomSheetBehavior.state = BottomSheetBehavior.STATE_EXPANDED
                }

                BottomSheetBehavior.STATE_EXPANDED -> {
                    bottomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED
                }

                else -> {
                    showBottomSheet()
                }
            }
        }

        bottomSheetBehavior.addBottomSheetCallback(object :
            BottomSheetBehavior.BottomSheetCallback() {

            override fun onStateChanged(bottomSheet: View, newState: Int) {
                if (newState != BottomSheetBehavior.STATE_SETTLING) {
                    savedBottomSheetState = newState
                }

                when (newState) {
                    BottomSheetBehavior.STATE_HIDDEN -> {
                        binding.overlay.isVisible = false
                        savedOverlayVisible = false
                    }

                    BottomSheetBehavior.STATE_COLLAPSED -> {
                        binding.overlay.isVisible = true
                        savedOverlayVisible = true
                        binding.overlay.alpha = 0.6f
                    }

                    BottomSheetBehavior.STATE_EXPANDED -> {
                        binding.overlay.isVisible = true
                        savedOverlayVisible = true
                        binding.overlay.alpha = 0.6f
                    }

                    else -> {
                        savedOverlayVisible = binding.overlay.isVisible
                    }
                }
            }

            override fun onSlide(bottomSheet: View, slideOffset: Float) {
                when {
                    slideOffset <= 0 -> {
                        val progress = (slideOffset + 1).coerceIn(0f, 1f)
                        if (progress > 0) {
                            overlay.visibility = View.VISIBLE
                            overlay.alpha = progress * 0.6f
                        } else {
                            overlay.visibility = View.GONE
                        }
                    }

                    else -> {
                        overlay.visibility = View.VISIBLE
                        overlay.alpha = 0.6f
                    }
                }
            }
        })

        binding.createNewPlaylistButtonSheet.setOnClickListener {
            returningFromNewPlaylist = true
            hideBottomSheet()
            findNavController().navigate(
                R.id.action_audioPlayerFragment_to_newPlaylistFragment
            )
        }

    }

    private fun toggleBottomSheet() {
        when (bottomSheetBehavior.state) {
            BottomSheetBehavior.STATE_HIDDEN -> {
                showBottomSheet()
            }

            BottomSheetBehavior.STATE_COLLAPSED, BottomSheetBehavior.STATE_EXPANDED -> {
                hideBottomSheet()
            }

            else -> {
                hideBottomSheet()
            }
        }
    }

    private fun showBottomSheet() {
        bottomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED
    }

    private fun hideBottomSheet() {
        bottomSheetBehavior.state = BottomSheetBehavior.STATE_HIDDEN
    }

    companion object {
        private const val ARG_TRACK = "track"
        private const val KEY_BOTTOM_SHEET_STATE = "bottom_sheet_state"
        private const val KEY_OVERLAY_VISIBLE = "overlay_visible"
        private const val KEY_RETURNING_FROM_NEW_PLAYLIST = "returning_from_new_playlist"

        @JvmStatic
        fun newInstance(track: Track) = AudioPlayerFragment().apply {
            arguments = Bundle().apply { putParcelable(ARG_TRACK, track) }
        }
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/player/PlaylistBottomSheetAdapter.kt ====
package com.practicum.playlistmaker.presentation.player

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.practicum.playlistmaker.databinding.BottomSheetPlaylistItemBinding
import com.practicum.playlistmaker.domain.playlist.Playlist
import com.practicum.playlistmaker.presentation.viewholder.PlaylistBottomSheetViewHolder

class PlaylistBottomSheetAdapter(
    private val playlists: MutableList<Playlist>, private val onClick: (Playlist) -> Unit
) : RecyclerView.Adapter<PlaylistBottomSheetViewHolder>() {

    fun update(newList: List<Playlist>) {
        playlists.clear()
        playlists.addAll(newList)
        notifyDataSetChanged()
    }

    override fun onCreateViewHolder(
        parent: ViewGroup,
        viewType: Int
    ): PlaylistBottomSheetViewHolder {
        val binding = BottomSheetPlaylistItemBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        )
        return PlaylistBottomSheetViewHolder(binding)
    }

    override fun onBindViewHolder(holder: PlaylistBottomSheetViewHolder, position: Int) {
        val playlist = playlists[position]
        holder.bind(playlist)
        holder.itemView.setOnClickListener { onClick(playlist) }
    }

    override fun getItemCount(): Int = playlists.size
}

==== ./app/src/main/java/com/practicum/playlistmaker/presentation/player/AudioPlayerViewModel.kt ====
package com.practicum.playlistmaker.presentation.player

import android.media.MediaPlayer
import android.util.Log
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.asLiveData
import androidx.lifecycle.viewModelScope
import com.practicum.playlistmaker.domain.favorites.AddToFavoritesUseCase
import com.practicum.playlistmaker.domain.favorites.IsFavoriteUseCase
import com.practicum.playlistmaker.domain.favorites.RemoveFromFavoritesUseCase
import com.practicum.playlistmaker.domain.playlist.AddTrackResult
import com.practicum.playlistmaker.domain.playlist.AddTrackToPlaylistUseCase
import com.practicum.playlistmaker.domain.playlist.GetPlaylistsUseCase
import com.practicum.playlistmaker.domain.playlist.Playlist
import com.practicum.playlistmaker.domain.track.Track
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch

sealed class AddTrackStatus {
    data class Success(val playlistName: String) : AddTrackStatus()
    data class AlreadyExists(val playlistName: String) : AddTrackStatus()
    class Error(val message: String) : AddTrackStatus()
}

class AudioPlayerViewModel(
    private val mediaPlayer: MediaPlayer,
    private val addToFavoritesUseCase: AddToFavoritesUseCase,
    private val removeFromFavoritesUseCase: RemoveFromFavoritesUseCase,
    private val isFavoriteUseCase: IsFavoriteUseCase,
    private val getPlaylistsUseCase: GetPlaylistsUseCase,
    private val addTrackToPlaylistUseCase: AddTrackToPlaylistUseCase
) : ViewModel() {

    private val _state = MutableLiveData(AudioPlayerScreenState())
    val state: LiveData<AudioPlayerScreenState> = _state

    private var currentTrack: Track? = null
    private var isPrepared = false
    private var isCompleted = false
    private var updateProgressJob: Job? = null

    private var wasPlayingBeforeConfigChange = false
    private var lastPositionBeforeConfigChange = 0

    val playlists: LiveData<List<Playlist>> = getPlaylistsUseCase.execute().asLiveData()

    private val _addTrackStatus = MutableLiveData<AddTrackStatus?>()
    val addTrackStatus: LiveData<AddTrackStatus> = _addTrackStatus as LiveData<AddTrackStatus>

    private val _shouldCloseBottomSheet = MutableLiveData<Boolean?>()
    val shouldCloseBottomSheet: LiveData<Boolean> = _shouldCloseBottomSheet as LiveData<Boolean>

    fun setTrack(track: Track) {
        if (currentTrack?.trackId == track.trackId && isPrepared) {
            updateTrackState(track)
            if (wasPlayingBeforeConfigChange && lastPositionBeforeConfigChange > 0) {
                mediaPlayer.seekTo(lastPositionBeforeConfigChange)
                if (wasPlayingBeforeConfigChange && !mediaPlayer.isPlaying) {
                    mediaPlayer.start()
                    _state.value = _state.value?.copy(isPlaying = true, currentPosition = lastPositionBeforeConfigChange)
                    startUpdatingProgress()
                }
                wasPlayingBeforeConfigChange = false
                lastPositionBeforeConfigChange = 0
            }
            return
        }

        stopPlayer()

        wasPlayingBeforeConfigChange = _state.value?.isPlaying == true
        lastPositionBeforeConfigChange = _state.value?.currentPosition ?: 0

        currentTrack = track
        updateTrackState(track)

        track.previewUrl?.let { initPlayer(it) }
    }

    private fun updateTrackState(track: Track) {
        viewModelScope.launch {
            val isFav = track.trackId?.let { isFavoriteUseCase.execute(it) } ?: false
            _state.value = _state.value?.copy(
                track = track,
                isFavorite = isFav,
                currentPosition = 0
            )
        }
    }

    fun startPlayer() {
        if (isPrepared && !mediaPlayer.isPlaying) {
            if (isCompleted) {
                mediaPlayer.seekTo(0)
                isCompleted = false
            }
            mediaPlayer.start()
            _state.value = _state.value?.copy(isPlaying = true)
            startUpdatingProgress()
        } else if (!isPrepared) {
            currentTrack?.previewUrl?.let {
                initPlayer(it)
                viewModelScope.launch {
                    delay(100)
                    if (isPrepared) {
                        startPlayer()
                    }
                }
            }
        }
    }

    fun resetAddTrackStatus() {
        _addTrackStatus.value = null
    }

    fun addTrackToPlaylist(playlist: Playlist, track: Track) {
        if (playlist.trackIds.contains(track.trackId)) {
            _addTrackStatus.value = AddTrackStatus.AlreadyExists(playlist.title)
            _shouldCloseBottomSheet.value = false
            return
        }

        viewModelScope.launch {
            when (val result = addTrackToPlaylistUseCase.execute(playlist.id, track)) {
                is AddTrackResult.Success -> {
                    _addTrackStatus.value = AddTrackStatus.Success(result.playlistName)
                    _shouldCloseBottomSheet.value = true
                    loadPlaylists()
                }

                is AddTrackResult.AlreadyExists -> {
                    _addTrackStatus.value = AddTrackStatus.AlreadyExists(result.playlistName)
                    _shouldCloseBottomSheet.value = false
                }

                is AddTrackResult.Error -> {
                    _addTrackStatus.value = AddTrackStatus.Error(result.message)
                    _shouldCloseBottomSheet.value = true
                }
            }
        }
    }

    fun resetShouldCloseBottomSheet() {
        _shouldCloseBottomSheet.value = null
    }

    private fun loadPlaylists() {
        viewModelScope.launch {
            getPlaylistsUseCase.execute().collect {}
        }
    }

    fun pausePlayer() {
        if (isPrepared && mediaPlayer.isPlaying) {
            mediaPlayer.pause()
            _state.value = _state.value?.copy(isPlaying = false)
            stopUpdatingProgress()
        }
    }

    private fun stopPlayer() {
        if (isPrepared) {
            try {
                mediaPlayer.stop()
            } catch (e: IllegalStateException) {
            }
        }
        stopUpdatingProgress()
        isPrepared = false
        isCompleted = false
    }

    private fun startUpdatingProgress() {
        stopUpdatingProgress()
        updateProgressJob = viewModelScope.launch {
            while (isActive) {
                val position = try {
                    if (isPrepared && mediaPlayer.isPlaying) {
                        mediaPlayer.currentPosition
                    } else {
                        _state.value?.currentPosition ?: 0
                    }
                } catch (e: IllegalStateException) {
                    _state.value?.currentPosition ?: 0
                }
                _state.value = _state.value?.copy(currentPosition = position)
                delay(300)
            }
        }
    }

    private fun stopUpdatingProgress() {
        updateProgressJob?.cancel()
        updateProgressJob = null
    }

    private fun initPlayer(previewUrl: String) {
        try {
            stopUpdatingProgress()

            mediaPlayer.reset()
            isPrepared = false
            isCompleted = false

            mediaPlayer.setDataSource(previewUrl)

            mediaPlayer.setOnPreparedListener {
                isPrepared = true
                if (wasPlayingBeforeConfigChange) {
                    mediaPlayer.seekTo(lastPositionBeforeConfigChange)
                    mediaPlayer.start()
                    _state.value = _state.value?.copy(isPlaying = true, currentPosition = lastPositionBeforeConfigChange)
                    startUpdatingProgress()
                    wasPlayingBeforeConfigChange = false
                    lastPositionBeforeConfigChange = 0
                }
            }

            mediaPlayer.setOnCompletionListener {
                stopUpdatingProgress()
                isCompleted = true
                _state.value = _state.value?.copy(isPlaying = false, currentPosition = 0)
            }

            mediaPlayer.setOnErrorListener { mp, what, extra ->
                Log.e("AudioPlayerViewModel", "MediaPlayer error: what=$what, extra=$extra")
                false
            }

            mediaPlayer.prepareAsync()

        } catch (e: Exception) {
            Log.e("AudioPlayerViewModel", "Error init player", e)
            isPrepared = false
        }
    }

    fun toggleFavorite() {
        viewModelScope.launch {
            val currentFav = _state.value?.isFavorite ?: false
            currentTrack?.trackId?.let { id ->
                if (currentFav) removeFromFavoritesUseCase.execute(id)
                else addToFavoritesUseCase.execute(currentTrack!!)
                _state.value = _state.value?.copy(isFavorite = !currentFav)
            }
        }
    }

    fun savePlaybackState() {
        wasPlayingBeforeConfigChange = _state.value?.isPlaying == true
        lastPositionBeforeConfigChange = _state.value?.currentPosition ?: 0
    }

    override fun onCleared() {
        super.onCleared()
        stopUpdatingProgress()
        try {
            mediaPlayer.release()
        } catch (e: Exception) {
            Log.e("AudioPlayerViewModel", "Error releasing MediaPlayer", e)
        }
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/presentation/theme/ThemeViewModel.kt ====
package com.practicum.playlistmaker.presentation.theme

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import com.practicum.playlistmaker.domain.theme.GetThemeUseCase
import com.practicum.playlistmaker.domain.theme.SwitchThemeUseCase
import com.practicum.playlistmaker.presentation.settings.SettingsUiEvent
import com.practicum.playlistmaker.presentation.settings.SingleLiveEvent

class ThemeViewModel(
    private val switchThemeUseCase: SwitchThemeUseCase,
    private val getThemeUseCase: GetThemeUseCase
) : ViewModel() {

    private val _state = MutableLiveData(ThemeScreenState())
    val state: LiveData<ThemeScreenState> = _state

    private val _uiEvent = SingleLiveEvent<SettingsUiEvent>()
    val uiEvent: LiveData<SettingsUiEvent> = _uiEvent

    init {
        _state.value = ThemeScreenState(isDarkMode = getThemeUseCase.execute())
    }

    fun switchTheme(darkMode: Boolean) {
        switchThemeUseCase.execute(darkMode)
        _state.value = _state.value?.copy(isDarkMode = darkMode)
    }

    fun onPracticumOfferClicked() {
        _uiEvent.value = SettingsUiEvent.OpenPracticumOffer
    }

    fun onSendToHelpdeskClicked() {
        _uiEvent.value = SettingsUiEvent.SendToHelpdesk
    }

    fun onShareAppClicked() {
        _uiEvent.value = SettingsUiEvent.ShareApp
    }
}
==== ./app/src/main/java/com/practicum/playlistmaker/presentation/theme/ThemeScreenState.kt ====
package com.practicum.playlistmaker.presentation.theme

data class ThemeScreenState(
    val isDarkMode: Boolean = false
)==== ./app/src/main/java/com/practicum/playlistmaker/domain/track/SearchTracksUseCase.kt ====
package com.practicum.playlistmaker.domain.track

import kotlinx.coroutines.flow.Flow

class SearchTracksUseCase(private val repository: TracksRepository) {
    fun execute(searchText: String): Flow<List<Track>> {
        return repository.searchTrack(searchText)
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/track/Track.kt ====
package com.practicum.playlistmaker.domain.track

import android.os.Parcelable
import kotlinx.parcelize.Parcelize
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

@Parcelize
data class Track(
    val id: Long,
    val trackId: Int?,
    val trackName: String?,
    val artistsName: String?,
    val trackTimeMillis: Long?,
    val artworkUrl100: String?,
    val previewUrl: String?,
    val collectionName: String?,
    val releaseDate: String?,
    val primaryGenreName: String?,
    val country: String?
) : Parcelable {
    val trackTime: String?
        get() = trackTimeMillis?.let {
            SimpleDateFormat("mm:ss", Locale.getDefault()).format(Date(it))
        }

    val releaseYear: String?
        get() = releaseDate?.let {
            try {
                val inputFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.getDefault())
                val date = inputFormat.parse(it)
                val outputFormat = SimpleDateFormat("yyyy", Locale.getDefault())
                outputFormat.format(date!!)
            } catch (e: Exception) {
                null
            }
        }

    fun getConvertArtwork(): String {
        return artworkUrl100?.replaceAfterLast("/", "512x512bb.jpg") ?: ""
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/track/TracksRepository.kt ====
package com.practicum.playlistmaker.domain.track

import kotlinx.coroutines.flow.Flow

interface TracksRepository {
    fun searchTrack(searchString: String): Flow<List<Track>>
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/favorites/AddToFavoritesUseCase.kt ====
package com.practicum.playlistmaker.domain.favorites

import com.practicum.playlistmaker.domain.track.Track

class AddToFavoritesUseCase(private val repo: FavoritesRepository) {
    suspend fun execute(track: Track) = repo.add(track)
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/favorites/GetFavoritesUseCase.kt ====
package com.practicum.playlistmaker.domain.favorites

class GetFavoritesUseCase(private val repo: FavoritesRepository) {
    fun execute() = repo.getFavorites()
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/favorites/RemoveFromFavoritesUseCase.kt ====
package com.practicum.playlistmaker.domain.favorites

class RemoveFromFavoritesUseCase(private val repo: FavoritesRepository) {
    suspend fun execute(trackId: Int) = repo.remove(trackId)
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/favorites/FavoritesRepository.kt ====
package com.practicum.playlistmaker.domain.favorites

import com.practicum.playlistmaker.domain.track.Track
import kotlinx.coroutines.flow.Flow

interface FavoritesRepository {
    suspend fun add(track: Track)
    suspend fun remove(trackId: Int)
    fun getFavorites(): Flow<List<Track>>
    suspend fun isFavorite(trackId: Int): Boolean
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/favorites/IsFavoriteUseCase.kt ====
package com.practicum.playlistmaker.domain.favorites

class IsFavoriteUseCase(private val repo: FavoritesRepository) {
    suspend fun execute(trackId: Int) = repo.isFavorite(trackId)
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/history/AddTrackToHistoryUseCase.kt ====
package com.practicum.playlistmaker.domain.history

import com.practicum.playlistmaker.domain.track.Track
class AddTrackToHistoryUseCase(
    private val repository: SearchHistoryRepository
) {
    fun execute(track: Track) {
        repository.addTrack(track)
    }
}
==== ./app/src/main/java/com/practicum/playlistmaker/domain/history/ClearSearchHistoryUseCase.kt ====
package com.practicum.playlistmaker.domain.history

class ClearSearchHistoryUseCase(
    private val repository: SearchHistoryRepository
) {
    fun execute() {
        repository.clearHistory()
    }
}
==== ./app/src/main/java/com/practicum/playlistmaker/domain/history/GetSearchHistoryUseCase.kt ====
package com.practicum.playlistmaker.domain.history

import com.practicum.playlistmaker.domain.track.Track

class GetSearchHistoryUseCase(
    private val repository: SearchHistoryRepository
) {
    fun execute(): List<Track> = repository.getHistory()
}
==== ./app/src/main/java/com/practicum/playlistmaker/domain/history/SearchHistoryRepository.kt ====
package com.practicum.playlistmaker.domain.history

import com.practicum.playlistmaker.domain.track.Track

interface SearchHistoryRepository {

    fun getHistory(): List<Track>

    fun addTrack(track: Track)

    fun clearHistory()
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/playlist/GetPlaylistByIdUseCase.kt ====
package com.practicum.playlistmaker.domain.playlist

class GetPlaylistByIdUseCase(
    private val repository: NewPlaylistRepository
) {
    suspend fun execute(playlistId: Long): Playlist? {
        return repository.getPlaylistById(playlistId)
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/playlist/CoverFileManager.kt ====
package com.practicum.playlistmaker.data.playlist

import android.content.Context
import android.net.Uri
import java.io.File
import java.io.FileOutputStream
import java.util.UUID

class CoverFileManager(private val context: Context) {

    fun copyCoverToInternalStorage(uri: Uri): String? {
        return try {
            val inputStream = context.contentResolver.openInputStream(uri)
            inputStream?.use { input ->
                val coversDir = File(context.filesDir, "playlist_covers")
                if (!coversDir.exists()) {
                    coversDir.mkdirs()
                }

                val fileName = "cover_${UUID.randomUUID()}.jpg"
                val outputFile = File(coversDir, fileName)

                FileOutputStream(outputFile).use { output ->
                    input.copyTo(output)
                }

                outputFile.absolutePath
            }
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/playlist/NewPlaylistRepository.kt ====
package com.practicum.playlistmaker.domain.playlist

import android.net.Uri
import kotlinx.coroutines.flow.Flow

interface NewPlaylistRepository {
    suspend fun createPlaylist(title: String, description: String?, coverUri: Uri?)
    fun getPlaylists(): Flow<List<Playlist>>
    suspend fun getPlaylistById(id: Long): Playlist?
    suspend fun updateTrackCount(id: Long, count: Int)
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/playlist/Playlist.kt ====
package com.practicum.playlistmaker.domain.playlist

import com.practicum.playlistmaker.domain.track.Track


data class Playlist(
    val id: Long,
    val title: String,
    val description: String?,
    val coverUri: String?,
    val tracksCount: List<Track> = emptyList(),
    val trackCount: Int = tracksCount.size
) {
    val trackIds: List<Int>
        get() = tracksCount.mapNotNull { it.trackId }
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/playlist/CreatePlaylistUseCase.kt ====
package com.practicum.playlistmaker.domain.playlist

import android.net.Uri
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class CreatePlaylistUseCase(
    private val repository: NewPlaylistRepository
) {
    suspend fun execute(
        title: String, description: String?, coverUri: Uri?
    ) {
        withContext(Dispatchers.IO) {
            repository.createPlaylist(
                title = title, description = description, coverUri = coverUri
            )
        }
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/playlist/AddTrackToPlaylistUseCase.kt ====
package com.practicum.playlistmaker.domain.playlist

import com.practicum.playlistmaker.domain.track.Track

class AddTrackToPlaylistUseCase(
    private val repository: PlaylistTracksRepository,
    private val playlistRepository: NewPlaylistRepository
) {
    suspend fun execute(playlistId: Long, track: Track): AddTrackResult {
        val playlist = playlistRepository.getPlaylistById(playlistId)
        val playlistName = playlist?.title ?: "Unknown"

        val existingTracks = repository.getTracksOnce(playlistId)
        val isAlreadyInPlaylist = existingTracks.any { it.trackId == track.trackId }

        if (isAlreadyInPlaylist) {
            return AddTrackResult.AlreadyExists(playlistName)
        }

        try {
            repository.addTrack(playlistId, track)
            val tracks = repository.getTracksOnce(playlistId)
            playlistRepository.updateTrackCount(playlistId, tracks.size)
            return AddTrackResult.Success(playlistName)
        } catch (e: Exception) {
            return AddTrackResult.Error(e.message ?: "Неизвестная ошибка")
        }
    }
}

sealed interface AddTrackResult {
    data class Success(val playlistName: String) : AddTrackResult
    data class AlreadyExists(val playlistName: String) : AddTrackResult
    data class Error(val message: String) : AddTrackResult
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/playlist/GetPlaylistsUseCase.kt ====
package com.practicum.playlistmaker.domain.playlist

class GetPlaylistsUseCase(
    private val repository: NewPlaylistRepository
) {
    fun execute() = repository.getPlaylists()
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/playlist/DeleteTrackFromPlaylistUseCase.kt ====
package com.practicum.playlistmaker.domain.playlist

class DeleteTrackFromPlaylistUseCase(
    private val repository: PlaylistTracksRepository,
    private val playlistRepository: NewPlaylistRepository
) {
    suspend fun execute(playlistId: Long, trackId: Int?) {
        if (trackId == null) return

        repository.removeTrack(playlistId, trackId)

        val tracks = repository.getTracksOnce(playlistId)
        playlistRepository.updateTrackCount(playlistId, tracks.size)
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/playlist/GetTracksForPlaylistUseCase.kt ====
package com.practicum.playlistmaker.domain.playlist

import com.practicum.playlistmaker.domain.track.Track

class GetTracksForPlaylistUseCase(
    private val repository: PlaylistTracksRepository
) {
    suspend fun execute(playlistId: Long): List<Track> {
        return repository.getTracksOnce(playlistId)
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/playlist/PlaylistTracksRepository.kt ====
package com.practicum.playlistmaker.domain.playlist

import com.practicum.playlistmaker.domain.track.Track
import kotlinx.coroutines.flow.Flow

interface PlaylistTracksRepository {
    suspend fun addTrack(playlistId: Long, track: Track)
    fun getTracks(playlistId: Long): Flow<List<Track>>
    suspend fun getTracksOnce(playlistId: Long): List<Track>
    suspend fun removeTrack(playlistId: Long, trackId: Int)

}==== ./app/src/main/java/com/practicum/playlistmaker/domain/theme/ThemeRepository.kt ====
package com.practicum.playlistmaker.domain.theme

interface ThemeRepository {
    fun switchTheme(darkMode: Boolean)
    fun isDarkMode(): Boolean
    fun applyTheme()
}
==== ./app/src/main/java/com/practicum/playlistmaker/domain/theme/GetThemeUseCase.kt ====
package com.practicum.playlistmaker.domain.theme

class GetThemeUseCase(private val repository: ThemeRepository) {
    fun execute(): Boolean {
        return repository.isDarkMode()
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/domain/theme/SwitchThemeUseCase.kt ====
package com.practicum.playlistmaker.domain.theme

class SwitchThemeUseCase(private val repository: ThemeRepository) {
    fun execute(darkMode: Boolean) {
        repository.switchTheme(darkMode)
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/di/PresentationModule.kt ====
package com.practicum.playlistmaker.di

import android.media.AudioAttributes
import android.media.MediaPlayer
import com.practicum.playlistmaker.presentation.media.FavoritesViewModel
import com.practicum.playlistmaker.presentation.media.MediaViewModel
import com.practicum.playlistmaker.presentation.media.NewPlaylistViewModel
import com.practicum.playlistmaker.presentation.media.PlaylistViewModel
import com.practicum.playlistmaker.presentation.media.PlaylistsViewModel
import com.practicum.playlistmaker.presentation.player.AudioPlayerViewModel
import com.practicum.playlistmaker.presentation.search.SearchViewModel
import com.practicum.playlistmaker.presentation.theme.ThemeViewModel
import org.koin.core.module.dsl.viewModel
import org.koin.dsl.module

val presentationModule = module {
    viewModel { ThemeViewModel(get(), get()) }
    viewModel { SearchViewModel(get(), get(), get(), get()) }
    viewModel { MediaViewModel() }
    viewModel { FavoritesViewModel(get()) }
    viewModel { PlaylistsViewModel(get()) }

    factory {
        MediaPlayer().apply {
            setAudioAttributes(
                AudioAttributes.Builder().setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                    .setUsage(AudioAttributes.USAGE_MEDIA).build()
            )
        }
    }
    viewModel { AudioPlayerViewModel(get(), get(), get(), get(), get(), get()) }

    viewModel { NewPlaylistViewModel(get()) }

    viewModel { PlaylistViewModel(get(), get(), get()) }

}==== ./app/src/main/java/com/practicum/playlistmaker/di/DomainModule.kt ====
package com.practicum.playlistmaker.di

import com.practicum.playlistmaker.domain.favorites.AddToFavoritesUseCase
import com.practicum.playlistmaker.domain.favorites.GetFavoritesUseCase
import com.practicum.playlistmaker.domain.favorites.IsFavoriteUseCase
import com.practicum.playlistmaker.domain.favorites.RemoveFromFavoritesUseCase
import com.practicum.playlistmaker.domain.history.AddTrackToHistoryUseCase
import com.practicum.playlistmaker.domain.history.ClearSearchHistoryUseCase
import com.practicum.playlistmaker.domain.history.GetSearchHistoryUseCase
import com.practicum.playlistmaker.domain.playlist.AddTrackToPlaylistUseCase
import com.practicum.playlistmaker.domain.playlist.CreatePlaylistUseCase
import com.practicum.playlistmaker.domain.playlist.DeleteTrackFromPlaylistUseCase
import com.practicum.playlistmaker.domain.playlist.GetPlaylistByIdUseCase
import com.practicum.playlistmaker.domain.playlist.GetPlaylistsUseCase
import com.practicum.playlistmaker.domain.playlist.GetTracksForPlaylistUseCase
import com.practicum.playlistmaker.domain.theme.GetThemeUseCase
import com.practicum.playlistmaker.domain.theme.SwitchThemeUseCase
import com.practicum.playlistmaker.domain.track.SearchTracksUseCase
import org.koin.dsl.module

val domainModule = module {
    // Theme
    factory { GetThemeUseCase(get()) }
    factory { SwitchThemeUseCase(get()) }

    // History
    factory { AddTrackToHistoryUseCase(get()) }
    factory { ClearSearchHistoryUseCase(get()) }
    factory { GetSearchHistoryUseCase(get()) }

    // Search
    factory { SearchTracksUseCase(get()) }

    // Favorites
    factory { AddToFavoritesUseCase(get()) }
    factory { RemoveFromFavoritesUseCase(get()) }
    factory { GetFavoritesUseCase(get()) }
    factory { IsFavoriteUseCase(get()) }

    // Playlist
    factory { CreatePlaylistUseCase(get()) }
    factory { GetPlaylistsUseCase(get()) }
    factory { AddTrackToPlaylistUseCase(get(), get()) }
    factory { GetPlaylistByIdUseCase(get()) }
    factory { GetTracksForPlaylistUseCase(get()) }
    factory { DeleteTrackFromPlaylistUseCase(get(), get()) }
}==== ./app/src/main/java/com/practicum/playlistmaker/di/DataModule.kt ====
package com.practicum.playlistmaker.di

import android.app.Application
import android.content.Context
import android.content.SharedPreferences
import androidx.room.Room
import com.google.gson.Gson
import com.practicum.playlistmaker.data.NetworkClient
import com.practicum.playlistmaker.data.favorites.FavoritesRepositoryImpl
import com.practicum.playlistmaker.data.favorites.db.AppDatabase
import com.practicum.playlistmaker.data.history.SearchHistoryRepositorImpl
import com.practicum.playlistmaker.data.network.ITunesApi
import com.practicum.playlistmaker.data.network.RetrofitNetworkClient
import com.practicum.playlistmaker.data.playlist.CoverFileManager
import com.practicum.playlistmaker.data.playlist.NewPlaylistRepositoryImpl
import com.practicum.playlistmaker.data.playlist.PlaylistTracksRepositoryImpl
import com.practicum.playlistmaker.data.repository.TracksRepositoryImpl
import com.practicum.playlistmaker.data.storage.SharedPrefs
import com.practicum.playlistmaker.data.theme.ThemeRepositoryImpl
import com.practicum.playlistmaker.domain.favorites.FavoritesRepository
import com.practicum.playlistmaker.domain.history.SearchHistoryRepository
import com.practicum.playlistmaker.domain.playlist.NewPlaylistRepository
import com.practicum.playlistmaker.domain.playlist.PlaylistTracksRepository
import com.practicum.playlistmaker.domain.theme.ThemeRepository
import com.practicum.playlistmaker.domain.track.TracksRepository
import org.koin.core.qualifier.named
import org.koin.dsl.module
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory

val dataModule = module {
    single<SharedPreferences>(named(Qualifiers.SETTINGS_PREFS)) {
        get<Application>().getSharedPreferences(
            SharedPrefs.PREFS_SETTINGS, Context.MODE_PRIVATE
        )
    }

    single<SharedPreferences>(named(Qualifiers.SEARCH_PREFS)) {
        get<Application>().getSharedPreferences(
            SharedPrefs.PREFS_SEARCH_HISTORY, Context.MODE_PRIVATE
        )
    }

    // File Manager for playlist covers
    single { CoverFileManager(get()) }

    // Theme
    single<ThemeRepository> {
        ThemeRepositoryImpl(get(named(Qualifiers.SETTINGS_PREFS)), get<Application>())
    }

    // History
    single<SearchHistoryRepository> {
        SearchHistoryRepositorImpl(get(named(Qualifiers.SEARCH_PREFS)), get())
    }

    // Gson
    single { Gson() }

    // Retrofit
    single {
        Retrofit.Builder().baseUrl("https://itunes.apple.com")
            .addConverterFactory(GsonConverterFactory.create()).build()
    }
    single { get<Retrofit>().create(ITunesApi::class.java) }
    single<NetworkClient> { RetrofitNetworkClient(get()) }

    // Tracks
    single<TracksRepository> { TracksRepositoryImpl(get()) }

    // Favorites
    single {
        Room.databaseBuilder(
            get(), AppDatabase::class.java, "playlist_maker_db"
        ).build()
    }

    single { get<AppDatabase>().favoritesDao() }

    single<FavoritesRepository> { FavoritesRepositoryImpl(get()) }

    // Playlist
    single<NewPlaylistRepository> {
        NewPlaylistRepositoryImpl(
            playlistDao = get<AppDatabase>().playlistDao(),
            playlistTrackDao = get<AppDatabase>().playlistTrackDao(),
            coverFileManager = get()
        )
    }

    single { get<AppDatabase>().playlistTrackDao() }

    single<PlaylistTracksRepository> { PlaylistTracksRepositoryImpl(get()) }
}==== ./app/src/main/java/com/practicum/playlistmaker/di/Qualifiers.kt ====
package com.practicum.playlistmaker.di

object Qualifiers {
    const val SETTINGS_PREFS = "settingsPrefs"
    const val SEARCH_PREFS = "searchPrefs"
}==== ./app/src/main/java/com/practicum/playlistmaker/di/AppModule.kt ====
package com.practicum.playlistmaker.di

import org.koin.dsl.module

val appModule = module {
    includes(
        dataModule, domainModule, presentationModule
    )
}
==== ./app/src/main/java/com/practicum/playlistmaker/data/NetworkClient.kt ====
package com.practicum.playlistmaker.data

import com.practicum.playlistmaker.data.dto.Response

interface NetworkClient {
    suspend fun doRequest(dto: Any): Response
}==== ./app/src/main/java/com/practicum/playlistmaker/data/storage/SharedPrefs.kt ====
package com.practicum.playlistmaker.data.storage

class SharedPrefs {
    companion object {
        const val PREFS_SETTINGS = "settings"
        const val DARK_MODE_KEY = "dark_mode"
        const val PREFS_SEARCH_HISTORY = "search_history"
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/data/network/RetrofitNetworkClient.kt ====
package com.practicum.playlistmaker.data.network

import com.practicum.playlistmaker.data.NetworkClient
import com.practicum.playlistmaker.data.dto.Response
import com.practicum.playlistmaker.data.dto.TracksSearchRequest

class RetrofitNetworkClient(private val iTunesApi: ITunesApi) : NetworkClient {

    override suspend fun doRequest(dto: Any): Response {
        return if (dto is TracksSearchRequest) {
            val response = iTunesApi.findSong(dto.expression)
            response.apply { resultCode = 200 }
        } else {
            Response().apply { resultCode = 400 }
        }
    }
}
==== ./app/src/main/java/com/practicum/playlistmaker/data/network/ITunesApi.kt ====
package com.practicum.playlistmaker.data.network

import com.practicum.playlistmaker.data.dto.TracksSearchResponse
import retrofit2.http.GET
import retrofit2.http.Query

interface ITunesApi {
    @GET("/search?entity=song")
    suspend fun findSong(@Query("term") text: String): TracksSearchResponse
}==== ./app/src/main/java/com/practicum/playlistmaker/data/favorites/FavoritesRepositoryImpl.kt ====
package com.practicum.playlistmaker.data.favorites

import com.practicum.playlistmaker.data.favorites.db.FavoritesDao
import com.practicum.playlistmaker.data.favorites.mapper.toEntity
import com.practicum.playlistmaker.data.favorites.mapper.toTrack
import com.practicum.playlistmaker.domain.favorites.FavoritesRepository
import com.practicum.playlistmaker.domain.track.Track
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

class FavoritesRepositoryImpl(
    private val dao: FavoritesDao
) : FavoritesRepository {

    override suspend fun add(track: Track) {
        dao.addTrack(track.toEntity())
    }

    override suspend fun remove(trackId: Int) {
        dao.removeTrack(trackId)
    }

    override fun getFavorites(): Flow<List<Track>> =
        dao.getFavorites().map { list -> list.map { it.toTrack() } }

    override suspend fun isFavorite(trackId: Int): Boolean = dao.isFavorite(trackId)
}==== ./app/src/main/java/com/practicum/playlistmaker/data/favorites/entity/FavoriteTrackEntity.kt ====
package com.practicum.playlistmaker.data.favorites.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "favorite_tracks")
data class FavoriteTrackEntity(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    val trackId: Int,
    val trackName: String?,
    val artistsName: String?,
    val trackTimeMillis: Long?,
    val artworkUrl100: String?,
    val previewUrl: String?,
    val collectionName: String?,
    val releaseDate: String?,
    val primaryGenreName: String?,
    val country: String?
)==== ./app/src/main/java/com/practicum/playlistmaker/data/favorites/mapper/FavoriteTrackMapper.kt ====
package com.practicum.playlistmaker.data.favorites.mapper

import com.practicum.playlistmaker.data.favorites.entity.FavoriteTrackEntity
import com.practicum.playlistmaker.domain.track.Track


fun FavoriteTrackEntity.toTrack(): Track =
    Track(
        id,
        trackId,
        trackName,
        artistsName,
        trackTimeMillis,
        artworkUrl100,
        previewUrl,
        collectionName,
        releaseDate,
        primaryGenreName,
        country
    )

fun Track.toEntity(): FavoriteTrackEntity =
    FavoriteTrackEntity(
        id,
        trackId!!,
        trackName,
        artistsName,
        trackTimeMillis,
        artworkUrl100,
        previewUrl,
        collectionName,
        releaseDate,
        primaryGenreName,
        country
    )==== ./app/src/main/java/com/practicum/playlistmaker/data/favorites/db/AppDatabase.kt ====
package com.practicum.playlistmaker.data.favorites.db

import androidx.room.Database
import androidx.room.RoomDatabase
import com.practicum.playlistmaker.data.favorites.entity.FavoriteTrackEntity
import com.practicum.playlistmaker.data.playlist.db.PlaylistDao
import com.practicum.playlistmaker.data.playlist.db.PlaylistTrackDao
import com.practicum.playlistmaker.data.playlist.entity.PlaylistEntity
import com.practicum.playlistmaker.data.playlist.entity.PlaylistTrackEntity

@Database(
    entities = [FavoriteTrackEntity::class, PlaylistEntity::class, PlaylistTrackEntity::class],
    version = 1,
    exportSchema = false
)
abstract class AppDatabase : RoomDatabase() {
    abstract fun favoritesDao(): FavoritesDao
    abstract fun playlistDao(): PlaylistDao
    abstract fun playlistTrackDao(): PlaylistTrackDao
}==== ./app/src/main/java/com/practicum/playlistmaker/data/favorites/db/FavoritesDao.kt ====
package com.practicum.playlistmaker.data.favorites.db

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.practicum.playlistmaker.data.favorites.entity.FavoriteTrackEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface FavoritesDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun addTrack(track: FavoriteTrackEntity)

    @Query("DELETE FROM favorite_tracks WHERE trackId = :trackId")
    suspend fun removeTrack(trackId: Int)

    @Query("SELECT * FROM favorite_tracks ORDER BY id DESC")
    fun getFavorites(): Flow<List<FavoriteTrackEntity>>

    @Query("SELECT EXISTS(SELECT 1 FROM favorite_tracks WHERE trackId = :trackId)")
    suspend fun isFavorite(trackId: Int): Boolean
}==== ./app/src/main/java/com/practicum/playlistmaker/data/repository/TracksRepositoryImpl.kt ====
package com.practicum.playlistmaker.data.repository

import com.practicum.playlistmaker.data.NetworkClient
import com.practicum.playlistmaker.data.dto.TracksSearchRequest
import com.practicum.playlistmaker.data.dto.TracksSearchResponse
import com.practicum.playlistmaker.domain.track.Track
import com.practicum.playlistmaker.domain.track.TracksRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

class TracksRepositoryImpl(
    private val networkClient: NetworkClient
) : TracksRepository {

    override fun searchTrack(searchString: String): Flow<List<Track>> = flow {
        val response = networkClient.doRequest(TracksSearchRequest(searchString))
        if (response.resultCode == 200) {
            emit(
                (response as TracksSearchResponse).results.map {
                    Track(
                        it.id,
                        it.trackId,
                        it.trackName,
                        it.artistsName,
                        it.trackTimeMillis,
                        it.artworkUrl100,
                        it.previewUrl,
                        it.collectionName,
                        it.releaseDate,
                        it.primaryGenreName,
                        it.country
                    )
                })
        } else {
            throw Exception("Network error: ${response.resultCode}")
        }
    }
}

==== ./app/src/main/java/com/practicum/playlistmaker/data/history/SearchHistoryRepositorImpl.kt ====
package com.practicum.playlistmaker.data.history

import android.content.SharedPreferences
import androidx.core.content.edit
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import com.practicum.playlistmaker.data.storage.SharedPrefs
import com.practicum.playlistmaker.domain.history.SearchHistoryRepository
import com.practicum.playlistmaker.domain.track.Track

class SearchHistoryRepositorImpl(
    private val sharedPreferences: SharedPreferences, private val gson: Gson
) : SearchHistoryRepository {

    private val historyKey = SharedPrefs.PREFS_SEARCH_HISTORY
    private val maxHistorySize = 10

    override fun getHistory(): List<Track> {
        val json = sharedPreferences.getString(historyKey, null) ?: return emptyList()
        val type = object : TypeToken<List<Track>>() {}.type
        return gson.fromJson(json, type)
    }

    override fun addTrack(track: Track) {
        val history = getHistory().toMutableList()
        history.removeAll { it.trackId == track.trackId }
        history.add(0, track)
        if (history.size > maxHistorySize) {
            history.subList(maxHistorySize, history.size).clear()
        }
        saveHistory(history)
    }

    override fun clearHistory() {
        sharedPreferences.edit { remove(historyKey) }
    }

    private fun saveHistory(history: List<Track>) {
        val limitedHistory =
            if (history.size > maxHistorySize) history.subList(0, maxHistorySize) else history
        val json = gson.toJson(limitedHistory)
        sharedPreferences.edit { putString(historyKey, json) }
    }
}
==== ./app/src/main/java/com/practicum/playlistmaker/data/playlist/PlaylistTracksRepositoryImpl.kt ====
package com.practicum.playlistmaker.data.playlist

import com.practicum.playlistmaker.data.playlist.db.PlaylistTrackDao
import com.practicum.playlistmaker.data.playlist.mapper.toEntity
import com.practicum.playlistmaker.data.playlist.mapper.toTrack
import com.practicum.playlistmaker.domain.playlist.PlaylistTracksRepository
import com.practicum.playlistmaker.domain.track.Track
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

class PlaylistTracksRepositoryImpl(
    private val dao: PlaylistTrackDao
) : PlaylistTracksRepository {

    override suspend fun addTrack(playlistId: Long, track: Track) {
        val entity = track.toEntity(playlistId)
        dao.addTrackToPlaylist(entity)
    }

    override fun getTracks(playlistId: Long): Flow<List<Track>> =
        dao.getTracksFromPlaylist(playlistId).map { list ->
            list.map { it.toTrack() }
        }

    override suspend fun removeTrack(playlistId: Long, trackId: Int) {
        dao.removeTrackFromPlaylist(playlistId, trackId)
    }

    override suspend fun getTracksOnce(playlistId: Long): List<Track> {
        return dao.getTracksFromPlaylistOnce(playlistId).map { it.toTrack() }
    }
}
==== ./app/src/main/java/com/practicum/playlistmaker/data/playlist/entity/PlaylistEntity.kt ====
package com.practicum.playlistmaker.data.playlist.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "playlists")
data class PlaylistEntity(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    val title: String,
    val description: String?,
    val coverUri: String?,
    val trackCount: Int = 0
)
==== ./app/src/main/java/com/practicum/playlistmaker/data/playlist/entity/PlaylistTrackEntity.kt ====
package com.practicum.playlistmaker.data.playlist.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "playlist_tracks")
data class PlaylistTrackEntity(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    val playlistId: Long,
    val trackId: Int,
    val trackName: String?,
    val artistsName: String?,
    val trackTimeMillis: Long?,
    val artworkUrl100: String?,
    val previewUrl: String?,
    val collectionName: String?,
    val releaseDate: String?,
    val primaryGenreName: String?,
    val country: String?
)==== ./app/src/main/java/com/practicum/playlistmaker/data/playlist/mapper/PlaylistMapper.kt ====
package com.practicum.playlistmaker.data.playlist.mapper

import com.practicum.playlistmaker.data.playlist.entity.PlaylistEntity
import com.practicum.playlistmaker.domain.playlist.Playlist
import com.practicum.playlistmaker.domain.track.Track

fun PlaylistEntity.toDomain(tracks: List<Track> = emptyList()): Playlist {
    return Playlist(
        id = id, title = title, description = description, coverUri = coverUri, tracksCount = tracks
    )
}==== ./app/src/main/java/com/practicum/playlistmaker/data/playlist/mapper/PlaylistTrackMapper.kt ====
package com.practicum.playlistmaker.data.playlist.mapper

import com.practicum.playlistmaker.data.playlist.entity.PlaylistTrackEntity
import com.practicum.playlistmaker.domain.track.Track

fun Track.toEntity(playlistId: Long): PlaylistTrackEntity =
    PlaylistTrackEntity(
        playlistId = playlistId,
        trackId = trackId ?: 0,
        trackName = trackName,
        artistsName = artistsName,
        trackTimeMillis = trackTimeMillis,
        artworkUrl100 = artworkUrl100,
        previewUrl = previewUrl,
        collectionName = collectionName,
        releaseDate = releaseDate,
        primaryGenreName = primaryGenreName,
        country = country
    )

fun PlaylistTrackEntity.toTrack(): Track =
    Track(
        id = 0L,
        trackId = trackId,
        trackName = trackName,
        artistsName = artistsName,
        trackTimeMillis = trackTimeMillis,
        artworkUrl100 = artworkUrl100,
        previewUrl = previewUrl,
        collectionName = collectionName,
        releaseDate = releaseDate,
        primaryGenreName = primaryGenreName,
        country = country
    )
==== ./app/src/main/java/com/practicum/playlistmaker/data/playlist/db/PlaylistTrackDao.kt ====
package com.practicum.playlistmaker.data.playlist.db

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.practicum.playlistmaker.data.playlist.entity.PlaylistTrackEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface PlaylistTrackDao {
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun addTrackToPlaylist(track: PlaylistTrackEntity)

    @Query("SELECT * FROM playlist_tracks WHERE playlistId = :playlistId ORDER BY id DESC")
    fun getTracksFromPlaylist(playlistId: Long): Flow<List<PlaylistTrackEntity>>

    @Query("DELETE FROM playlist_tracks WHERE playlistId = :playlistId AND trackId = :trackId")
    suspend fun removeTrackFromPlaylist(playlistId: Long, trackId: Int)

    @Query("SELECT * FROM playlist_tracks WHERE playlistId = :playlistId")
    suspend fun getTracksFromPlaylistOnce(playlistId: Long): List<PlaylistTrackEntity>
}==== ./app/src/main/java/com/practicum/playlistmaker/data/playlist/db/PlaylistDao.kt ====
package com.practicum.playlistmaker.data.playlist.db

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.practicum.playlistmaker.data.playlist.entity.PlaylistEntity
import com.practicum.playlistmaker.data.playlist.entity.PlaylistTrackEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface PlaylistDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun addPlaylist(playlist: PlaylistEntity)

    @Query("SELECT * FROM playlists ORDER BY id DESC")
    fun getPlaylists(): Flow<List<PlaylistEntity>>

    @Query("SELECT * FROM playlists WHERE id = :playlistId LIMIT 1")
    suspend fun getPlaylistById(playlistId: Long): PlaylistEntity?

    @Query("UPDATE playlists SET trackCount = :count WHERE id = :playlistId")
    suspend fun updateTrackCount(playlistId: Long, count: Int)

}

==== ./app/src/main/java/com/practicum/playlistmaker/data/playlist/NewPlaylistRepositoryImpl.kt ====
package com.practicum.playlistmaker.data.playlist

import android.net.Uri
import com.practicum.playlistmaker.data.playlist.db.PlaylistDao
import com.practicum.playlistmaker.data.playlist.db.PlaylistTrackDao
import com.practicum.playlistmaker.data.playlist.entity.PlaylistEntity
import com.practicum.playlistmaker.data.playlist.mapper.toDomain
import com.practicum.playlistmaker.data.playlist.mapper.toTrack
import com.practicum.playlistmaker.domain.playlist.NewPlaylistRepository
import com.practicum.playlistmaker.domain.playlist.Playlist
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

class NewPlaylistRepositoryImpl(
    private val playlistDao: PlaylistDao,
    private val playlistTrackDao: PlaylistTrackDao,
    private val coverFileManager: CoverFileManager
) : NewPlaylistRepository {

    override suspend fun createPlaylist(title: String, description: String?, coverUri: Uri?) {
        val internalCoverPath = coverUri?.let { coverFileManager.copyCoverToInternalStorage(it) }

        val entity = PlaylistEntity(
            title = title,
            description = description,
            coverUri = internalCoverPath
        )
        playlistDao.addPlaylist(entity)
    }

    override fun getPlaylists(): Flow<List<Playlist>> {
        return playlistDao.getPlaylists().map { playlistEntities ->
            playlistEntities.map { playlistEntity ->
                val tracks = getTracksForPlaylist(playlistEntity.id)
                playlistEntity.toDomain(tracks)
            }
        }
    }

    override suspend fun getPlaylistById(id: Long): Playlist? {
        val entity = playlistDao.getPlaylistById(id) ?: return null
        val tracks = playlistTrackDao.getTracksFromPlaylistOnce(id).map { it.toTrack() }
        return entity.toDomain(tracks)
    }

    override suspend fun updateTrackCount(id: Long, count: Int) {
        playlistDao.updateTrackCount(id, count)
    }

    private suspend fun getTracksForPlaylist(playlistId: Long): List<com.practicum.playlistmaker.domain.track.Track> {
        return playlistTrackDao.getTracksFromPlaylistOnce(playlistId).map { it.toTrack() }
    }
}==== ./app/src/main/java/com/practicum/playlistmaker/data/dto/TrackDto.kt ====
package com.practicum.playlistmaker.data.dto

import com.google.gson.annotations.SerializedName

data class TrackDto(
    val id: Long,
    val trackId: Int?,
    val trackName: String?,
    @SerializedName("artistName") val artistsName: String?,
    val trackTimeMillis: Long?,
    val artworkUrl100: String?,
    val previewUrl: String?,
    val collectionName: String?,
    val releaseDate: String?,
    val primaryGenreName: String?,
    val country: String?
)
==== ./app/src/main/java/com/practicum/playlistmaker/data/dto/Response.kt ====
package com.practicum.playlistmaker.data.dto

open class Response() {
    var resultCode = 0
}==== ./app/src/main/java/com/practicum/playlistmaker/data/dto/TracksSearchResponse.kt ====
package com.practicum.playlistmaker.data.dto

class TracksSearchResponse(
    val results: List<TrackDto>) : Response()==== ./app/src/main/java/com/practicum/playlistmaker/data/dto/TracksSearchRequest.kt ====
package com.practicum.playlistmaker.data.dto

data class TracksSearchRequest(val expression: String)==== ./app/src/main/java/com/practicum/playlistmaker/data/theme/ThemeRepositoryImpl.kt ====
package com.practicum.playlistmaker.data.theme

import android.app.Application
import android.content.SharedPreferences
import android.content.res.Configuration
import androidx.appcompat.app.AppCompatDelegate
import androidx.core.content.edit
import com.practicum.playlistmaker.data.storage.SharedPrefs
import com.practicum.playlistmaker.domain.theme.ThemeRepository

class ThemeRepositoryImpl(
    private val sharedPreferences: SharedPreferences, private val app: Application
) : ThemeRepository {

    private val themeKey = SharedPrefs.DARK_MODE_KEY

    override fun isDarkMode(): Boolean {
        if (sharedPreferences.contains(themeKey)) {
            return sharedPreferences.getBoolean(themeKey, false)
        }
        val uiMode = app.resources.configuration.uiMode
        val systemDarkMode =
            (uiMode and Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES
        sharedPreferences.edit {
            putBoolean(themeKey, systemDarkMode)
        }

        return systemDarkMode
    }

    override fun switchTheme(darkMode: Boolean) {
        sharedPreferences.edit {
            putBoolean(themeKey, darkMode)
        }

        applyThemeInternal(darkMode)
    }

    override fun applyTheme() {
        applyThemeInternal(isDarkMode())
    }

    private fun applyThemeInternal(darkMode: Boolean) {
        AppCompatDelegate.setDefaultNightMode(
            if (darkMode) AppCompatDelegate.MODE_NIGHT_YES
            else AppCompatDelegate.MODE_NIGHT_NO
        )
    }
}
